# 코딩을 지탱하는 기술 - 원리로 깨우치는 프로그래밍 기법
- 니시오 히로카즈 (저)
- 프로그래밍 언어에는 다양한 개념이 왜 존재하고, 이런 개념들은 왜 탄생한 것일까 ?

### 1.효율적으로 언어 배우기

#### 1.1 비교를 통한 배움
- 많은 언어에서 공통적으로 사용되는 개념이 중요한 지식이다.

##### 규칙은 언어마다 다르다.
- 프로그래밍 언어의 교과서에는 다양한 규약이 기술되어 있지만, 그것은 절대적인 약속이 아니다.
- 세상에는 0이 참인 언어, 0이 거짓인 언어, 0이 참도 거짓도 아닌 언어가 존재한다.

#### 1.2 역사를 통한 배움
- 프로그래밍 언어도 사람이 만든 것이다.
- 그 언어가 어떤 흐름을 따라 만들어 졌는지 알게 되면 그 기능이 왜 필요한지 납득 할수 있게 된다.

##### 언어에 의존하지 않는 보편적인 지식의 습득
- 개별 언어 지식이 5년후, 10년 후에도 도움이 될지는 아무도 모른다.
- 몇가지 언어를 비교하거나 언어의 역사나 이유를 조사함으로, 언어가 바뀌어도 통용할 수 있는 이해력을 길러야 한다.

#### 1.3 정리
- '비교를 통한 배움' 이란 특정 언어로 프로그래밍을 배우는것이 아닌, 다수의 언어를 비교해가며 학습하는 것을 의미한다.
  - 무엇이 언어에 따라 다르고 무엇이 공통적인지 배울 수 있다.
- '역사를 통한 배움' 이란 언어가 어떻게 바뀌었고 바뀌기 전에는 어떤 의문점이 존재했는지 학습 하는 것을 의미한다.
  - 언어가 가지고 있는 기능이 왜 탄생했는지 알 수 있다.
  
### 2.프로그래밍 언어를 조감하다

#### 2.1 프로그래밍 언어 탄생의 역사
- 많은 것이 과거의 것을 발전시켜 만들어 졌다.
- 프로그래밍 언어는 인간을 편하게 하기 위해 만들어 졌다.

##### 케이블을 연결하다.
- 1946년 진공관을 사용한 거대한 컴퓨터 ENIAC 이 발명됬다.
- 17,468개의 진공관을 사용한 컴퓨터로 폭은 24미터나 됐다.
- 컴퓨터의 수 많은 단자에 케이블을 여기저기 연결하는 것이 프로그래밍 이었다.
- 프로그램을 변경할 때 마다 케이블의 연결을 바꾸는 것은 매우 힘든일이 었다.

##### 프로그램 내장 방식으로
- 1949년 EDSAC이 개발됐다.
- 테이프에 구멍을 뚫어 데이터를 표현하고, 컴퓨터가 이를 읽어 들이도록 한 구조다.
- 물리적 케이블을 교환하는 대신, 종이 테이프의 데이터를 읽어 들여 프로그램을 변경할 수 있었다.

##### FORTRAN의 등장
- 1954년 지금 사용하고 있는것과 비슷한 프로그래밍 언어인 FORTRAN이 고안 되었다.
- 1979년에 FORTRAN 설계자인 John Backus는 '내가 이룬 성과의 대부분은 나태함에서 오고 있다. 나는 프로그램을 짜는것을 좋아하지 않았다. 그래서 쉽게 짤 수 있는 시스템을 만들었다'

#### 2.2 프로그래밍 언어 탄생의 목적
- 프로그램은 어떤 것을 편하게 하기 위해 고안된 것이다.

`나태, 조바심, 자만심 - 프로그래머의 삼대 미덕`
- 나태
  - 전체 에너지 소비를 줄이기 위해 대부분의 능력을 집중하는 기질. 이렇게 노동력을 줄이기 위해 만든 프로그램은 다른 사람들도 사용하게 되며, 그 프로그램에 대한 질문에 일일히 답하는 수고를 덜기 위해 문서를 만들게 된다.
- 조바심
  - 프로그램이 느린것을 용납하지 않음
- 자만심
  - 틀린 것을 방치하지 않음을 의미한다.
  
##### 언어에 따라 다른 '편리함'의 의미
- 어떤 '편리함'을 목표로 했는지, 언어 설계자의 의도를 파악해야 한다.

##### 무엇을 편하게 하고 싶은 것인가?
- C++은 빠른 실행 속도를 중시하고 있는 언어다.
- C로 만든 코드보다 빠른 속도가 날 수 있도록 고안했지만, 결과적으로 언어 사양이 더 복잡해지고 말았다.
- Scheme는 언어 사양을 쉽게 파악할 수 있는 데 중점을 두고 있는 언어다.
- 언어 사양이 최소한이 되도록 했고, 사양서 전체가 50페이지 밖에 되지 않는다.

##### 어떤 프로그램을 편하게 만들고 싶은가?
- 올바른 설계는 사용하는 사람이 무엇을 목적으로 하고 있는지에 따라 달라진다.
- 다양한 설계 언어가 있는 것은 사람에 따라 다양한 목적이 있기 때문이다.

#### 2.3 정리
- 언어는 도구다. 어떤 언어가 자신의 목적에 적합한지는 그 언어를 사용할 때 자신이 어느 정도의 생산성을 발휘할 수 있는지로 판단할 수 있다.
- 자신이 어느정도 성과를 낼 수 있는지 고려해서 결정해야 한다.

### 3 문법의 탄생

#### 3.1 문법이란?
- 프로그래밍 언어에는 여러 가지 규칙 이 있다.
- 예) 덧셈보다는 곱셈의 우선순위가 높다.

##### 연산자 우선순위
- 옛날 계산기 중에는 1 + 2 * 3의 계산결과가 9가 되는것이 있었다.
  - (1 + 2) * 3 으로 되어 있었다.
- 지금 대부분의 프로그래밍 언어는 계산결과가 7이 된다.
- 프로그래밍 설계자가 + 보다 * 가 우선순위가 높기 때문에 먼저 계산한다는 규칙을 정했기 때문이다.
  - 사칙연산과 같아 이해하기 쉽다.

##### 문법은 언어 설계자가 정한 규칙
- 언어 설계자가 정한 규칙이 바로 문법이다.
- 문법은 언어에 따라 다르다.

#### 3.2 스택 머신과 FORTH
- FORTH 는 1958년 경에 개발되어 문법이 거의 존재하지 않는 언어이다.

##### 계산 순서
- FORTH에서는 1과 2를 더한다는 코드를 다음과 같이 표현한다.
```
1 2 +
```
- FORTH는 Stack을 사용한다.
- 값을 쌓아 두는 장소를 이용한다.
- 1 과 2를 순서대로 담아뒀다가 연산자인 +를 만나면 1과 2를 + 연산하는 것이다.

##### 현재도 살아있는 스택 머신
- FORTH와 같이 스택 기반의 언어를 직접 입력하는 경우는 많이 줄었을 것이다.
- 하지만 보이지 않는 곳에서 사용되고 있다.
- Java, Python, Ruby1.9 등은 스택 머신 형의 VM을 사용하고 있다.
- VM이 실행하는 명령열도 FORTH와 같은 구조로 되어 있다.
- Python이나 Ruby, Java로 프로그램을 짜면 그 프로그램은 내부적으로 FORTH와 같은 프로그램으로 변환되어 동작하고 있는 것이다.

#### 3.3 구문 트리와 LISP
- 1958년에 탄생한 LISP는 '하나의 구역을 표현하기 위해 항상 괄호를 사용하자'는 선택을 한 언어이다.

##### 계산의 흐름
- LISP로 1과 2를 더한다는 코드는 다음과 같이 표현한다.
```
(+ 1 2)
```

##### 현재도 살아있는 구문 트리
- 구문 트리가 사용되고 있는 것은 최신 언어도 마찬가지 이다.

`ast`
- abstract syntax tree 의 약어이다.
- 추상구문트리
- 복잡한 구문을 간단히 한 것이 추상 구문 트리이다.

#### 3.4 중위 표기법
- LISP에서 연산자는 연산 대상의 앞에 배치된다.
- FORTH에서 연산자는 연산 대상의 뒤에 배치된다.
- 연산자를 연산 대상 뒤에 두는것을 후위 표기법, 앞에 두는 것을 전위 표기법, 사이에 두는 것을 중위 표기법 이라고 한다.
- 3가지 방식은 식을 표현하기 위한 약속에 불과하다.
- 프로그래밍 언어가 탄생하기 이전부터 사람들은 주우이 표기법에 익숙했다.
- FORTRAN은 이 익숙한 방법을 적용할 수 있도록 만들어 졌다.

##### 구문 해석기
- 구문 해석기(Parser)는 소스코드를 문자열로 읽어 들여 해석하고, 그것을 구문 트리로 만드는 프로그램이다.

#### 3.5 정리
- 1 더하기 2에 3을 곱한다 는 똑같은 처리도, 언어에 따라 표현방법이 틀리다.
- 그러나 구문 트리로 표현하면 거의 동일하다.
- 이들 언어의 차이가 생긴 것은 **어떤 문자열을 쓰면 어떤 구문 트리가 생기는가** 라는 규칙이고 이것이 문법이다.

### 4 처리흐름 제어

#### 4.1 구조화 프로그래밍의 탄생
- 1960년대 후반 '사람이 프로그램을 보다 편하게 쓰고 읽을 수 있도록 규약을 만들자' 는 흐름을 타고 '구조화 프로그래밍' 이 태어났다.
- if while 문 등의 규칙을 도입하여 코드 구조를 쉽게 만들자는 생각이었다.

#### 4.2 if가 태어나기 이전

##### if는 왜 있는걸까?
`C언어`
```c
int main(){
  int x = 123;
  if (x == 456) {
    
  }
```

컴파일시 다음과 같은 어셈블리어 코드가 출력된다.
```asembley
_main:
  ...
  movl $123, -8(%rbp)
  movl -8(%rbp), %eax
  cmpl $456, %eax
  jne LBB1_2
  
LBB1_2:
```
- if else 가 아닌 '특정 조건을 만족하면 점프' 하는 명령을 택하고 있다.

##### if-else 사용의 장점
- '조건이 참인 경우와 거짓인 경우의 처리 흐름을 분배한다'는 패턴은 프로그램이에 빈번히 사용된다.
- 이것을 간단히 읽기 쉬운 형태로 쓰기 위해 if-else 구문이 새롭게 도입된 것이다.

#### 4.3 while, 반복되는 if를 읽기 쉽게 표현
- while 문은 '조건을 만족하고 있는 동안 블록 안의 내용을 반복하여 실행'하는 구문이다.

##### while문을 사용하는 방법
- 다음 코드는 'x > 0 을 만족하는 동안 x를 출력하고 x에서 1을 뺀다'는 처리를 반복한다.
`C언어`
```c
void use_while(int x){
  printf("use_while\n");
  while(x > 0){
    printf("%d\n", x);
    x--;
  }
}
```

#### 4.4 for, 수치를 증가시키는 while을 읽기 쉽게 표현
- while이 있으면 for는 필요없지 ㅇ낳아? 라고 생각하는 사람도 있는 듯하다.
- 그런 의문을 품는다고 해도 이상한 것이 없다.
- for문으로 가능한것은 while문으로도 가능하다.

##### for문을 사용하는 방법
`C언어`
```c
for(i = 0; i< N; i++){
  printf("%d\n", i);
}
```

##### for문을 사용하지 않는 방법
`C언어`
```c
i = 0;
while(i < N){
  printf("%d\n", i);
  i++
}
```
> while문에서는 루프밖에서, 루프조건식에서, 루프 마지막 총 3곳으로 코드가 분산되어 버린다.

##### foreach, 처리 대상으로 반복 제어
- for문이 한번 더 진화한것이 현재 많은 언어에서 사용하고 있는 foreach 구문이다.
- Java에서는 확장 for문 이라고 불리고 있지만, Perl, PHP, C# 등 많은 언어에서 foreach라고 불리고 있다.

> while은 조건식으로 반복을 제어한다. for 문은 횟수로 반복을 제어한다. foreach 구문은 처리 대상으로 반복을 제어한다.

foreach 구문은 '어떤 대상의 요소 전부에 어떤 처리를 한다' 는 코드를 쉽게 쓰기 위해 만들어졌다.
`Java`
```java
int[] items = new int[]{1, 2, 3, 4, 5};
for(int item: items){
  System.out.println(item);
}
```

#### 4.5 정리
- if문, while문, for문을 사용하지 않아도 프로그램을 짤 수 있다.
- 그러나 사용하는것이 보다 알기 쉬운 코드를 구성할 수 있다.
- 알기 쉬운 코드를 만들기 위해서 적극적으로 사용하도록 하자.

### 5 함수

#### 5.1 함수의 역할
- 함수는 **함수의 일부를 한 덩어리로 잘라내어 그 것에 이름을 붙이는 기능** 이다.

##### 함수의 이해
- 코드가 함수로 나뉘어져 있는것은 큰 조직이 부서로 나뉘어 져 있는것과 닮았다.
- 소스 코드의 행 수가 많아지면 전체를 파악하기 어렵게 된다.
- 그래서 몇 개의 행을 하나의 그룹으로 묶어서 거기에 이름을 붙이는것이 함수다.

##### 재사용
- 함수를 만드는것은 작은 부품을 조립해서 큰 부품을 만드는것 과 같다.
- 무선 조종 자동차에는 알칼리 전지나 모터가 들어있다.
- 아무것도 없는 상태라면 무선 조종 자동차를 만들기 위해 아칼리 전지나 모터도 만들어야 한다.
    - 이를 위해 모터가 어떻게 동작하는지 등에 대한 이해가 필요하다.
- 현실에서는 이를 최적으로 매치해 하나의 덩어리로 만든 것이 알칼리 전지 라는 이름으로 판매되어 쉽게 구하고 사용할 수 있다.

- 함수도 동일하다. 코드가 함수로 정리되어 제공되고 있어 쉽게 그 함수를 호출해서 사용할 수 있다.
- **전지** 라는 이름으로 인해 전지를 사용한 시스템을 간단히 이해할 수 있다.
- 전지의 구조를 잘 알지못해도 전지는 전기를 만들어 내는 것이다. 라는 지식만으로 무선 조종 자동차를 조립할 수 있다.

##### 프로그램 재사용의 특징
- 프로그램을 만드는 것과 물리적인 것을 만드는 것에서 크게 다른 점은 재사용하고 싶을때 드는 비용이다.
- 프로그램으로 리스트 내에 있는 모든 데이터를 어떤 함수로 처리하고 싶다면 N번 만큼 함수를 호출하면 된다.

> 몇 번이고 호출해서 사용하여 소스코드를 간결하게 유지할 수 있으며, 최소한의 단위로 잘라내어 정리함으로써 프로그램을 보다 쉽게 이해할 수 있게 된다.

#### 5.2 돌아가는 명령
- 소스 코드를 재사용하기 위해서는 goto 문 만으로는 역부족이다.
    - goto문으로 하지 못하는것 **원래 위치로 돌아가** 는 것이다.

> 원래 위치로 돌아가 는 명령이 가능하다면 코드를 재사용할 수 있게 된다.

#### 5.3 재귀 호출
- 재귀호출이란 함수 X안에서 함수 X 자신을 호출하는 것이다.
- 재귀 호출이 안되는 언어도 있었지만, 대부분의 언어가 채용하고 있는 코딩 기술이다.

##### 내포 구조 데이터의 효율적 처리
- 재귀호출은 꼭 필요한 것만은 아니다.
- 재귀호출을 사용하고 있는 프로그램은 재귀 호출 없이도 만들 수 있다.

`재귀호출이 탄생한 이유`
- 어떠한 처리를 재귀 호출을 사용해 만들면 매우 편하게 구현할 수 있다.
- **어떤 처리를 하는 도중 동일한 처리를 다른 대상에 대해 실행한다** 는 내포 형태의 처리이다.
- 내포된 데이터 구조를 따룰 때는 코드도 함유 구조가 되는 경우가 많다.

### 5.4 정리
- 프로그램의 규모가 커지면 전체적인 구조를 파악하기 어려워진다.
- 또한 비슷한 처리를 몇 번이고 반복해서 쓰고 싶어지는 경우도 생긴다.
- 함수는 이 문제를 해결하기 위해 탄생 했다.

> 코드가 무엇을 하고 있는지 파악하기 쉬우며, 그 함수를 다른 장소에서 호출하여 사용함으로써 재사용도 가능해진다.

### 6 에러 처리 

#### 6.1 프로그램도 실패를 한다.
- 예외 처리는 Java, C++, Pyhton, Ruby등 많은 현대 언어들이 지원하고 있는 기능이다.
- 프로그램도 실패를 한다. 예를들어, 파일에 무엇을 기록하려고 할 때 하드 디스크가 이미 꽉 차 있는경우 기록에 실패한다.
- 가스가 유출되고 있을때 검출기에 의해 경보가 울리지 않는다면 화재와 같은 대참사로 번질 위험이 있다.
- 프로그램 실패도 같은 원리이다.
- 매우 중요한 데이터를 디스크에 저장해서 무사히 기록됬다고 착각하고 원래 데이터를 지워 버릴 수 도 있다.
- 가스 누출 검지기 같은 **실패를 알리는 구조** 가 필요하다.

#### 6.2 실패를 어떻게 전달할까?
- 에러 처리를 구현하는 방법에는 크게 2가지가 있다.
- 하나는 **반환 값으로 실패를 전달**하면, 호출처가 반환 값을 체크해서 에러 처리를 하는 방법
- 다른 하나는 함수 호출하기 전 에러 처리 코드를 등록해두고, 실패시 에러코드로 점프하는 방법이다.

> 전자는 C언어에서 주로 사용하는 방법이고, 후자는 현재 에러 처리라고 불리는 기법이다.

##### 반환값으로 실패를 전달한다.
- 반환값으로 실패를 전달하는 방법은 C 언어를 비롯해서 많은 언어가 사용하고 있다.
- 하지만 2가지 문제점이 있다.

- 1.실패를 놓친다.
- 2.에러 처리 때문에 코드를 해석하기 어렵다.

##### 실패를 놓친다.
- 프로그래머가 반환값 확인을 잊어버렸을 때 실패를 놓치게 된다.
- 프로그래머도 사람이기 때문에 함수가 실패할 가능성이 있다는 사실을 잊어버린다.

> 반환값을 체크하지 않고, 성공했다고 생각해버리는 코드를 쓰게 된다.

##### 에러 처리 때문에 코드를 해석하기 어렵다.
- 모든 함수 호출을 제대로 체크하자. 그러면 실패를 놓치지 않는다. 라고 생각하고 코드를 쓰기 시작한다.

> 에러 처리 떄문에 소스 코드가 읽기 어려워 진다.

##### 점프로 에러 처리를 정리한다.
- 에러 처리를 정리하기 위해 예외를 사용할 수 있지만, C 언어에는 예외 기능이 없다.
- 그래서 goto를 사용한다.

`C언어`
```java
int main() {
    if(!shippai("A")) goto ERROR;
    if(!shippai("B")) goto ERROR;
    if(!shippai("C")) goto ERROR;
    if(!shippai("D")) goto ERROR;
    return;
ERROR:
    /* 실패시 처리 ... */
}
```

> 코드 상에서는 '실패했을때 처리'가 '원래 하고싶은것을 기술한 코드'와 분리되어 있다.

##### 실패하면 점프한다.
- C언어가 나오기 한참 전 부터 다른 방법의 에러 처리가 존재했다.
- '에러가 발생했을 때 점프할 장소를 사전에 등록해두는' 방법 이다.
- 이 방법이 발전해서 현재의 '예외 처리'가 된 것이다.

##### UNIVAC I 의 경우
- '에러가 발생했을 때 점프한다'는 발상은 프로그래밍 언어보다 먼저 존재했다.
- 계산시 오버플로우가 발생하면 XXX번지에 있는 명령을 실행한다 는 기능이 있었다.

> 이런 기능을 인터럽트 (interrupt) 라고 불렀으며, 현재에도 에러 처리 뿐 아니라 다양한 목적으로 사용된다.

##### COBOL의 경우
- 현대의 예외 처리가 범용적 구문인 것과 달리 2 가지 에러 처리를 위해 각각의 별도 구문이 사용 되었다.
- 하나는 'READ'로 파일을 읽을때 'AT END'라는 구문으로 더이상 데이터가 없다는 등 처리
- 다른 하나는 'ADD' 등으로 수치 계산시 오버플로우 등 에러 발생시 'ON SIZE ERROR'와 같은 구문으로 처리

> 에러 처리는 이 2가지 밖에 없어서 현대 예외처리와는 달리 프로그래머가 에러 종류를 늘릴 수 없었따.

#### 6.3 실패할 것 같은 처리를 묶는 구문
- try { ... } 로 묶어둔 후 실패했을때 처리를 쓰는 형식이다.

#### 6.4 출구는 하나다.

##### 왜 finally를 도입한 것일까 ?
- 구조화 예외 처리를 채용함으로 코드의 신뢰성을 높일 수 있었다.
- 예를 들어 프로그래머가 예측하지 못한 종료가 발생했을시 메모리 블록이나 파일 등의 리소스를 잘 닫을 수 있게 된다.

#### 6.5 어떤 경우에 예외를 던질까 ?
- 에러가 발생하면 그것을 알리는 방법은 '반환값을 사용하는 방법' 과 '예외를 던지는 방법' 두가지가 있다.

##### 틀리면 바로 예외를 던진다.
- 작은 규모의 프로그램의 경우에는 바로 예외를 던지는 것이 JavaScript처럼 undefined 처리하는 것보다 좋다.
- '이상하면 처리르 정지하고 빨리 보고해야 한다'는 설계 이념을 **페일 퍼스트(fail first)** 라고 부른다.
- 소프트웨어의 목적에 따라 간단히 정지되면 곤란한 경우도 있지만, 개발 단계에서는 틀리면 바로 틀린 것을 발견하는 것이 오히려 이점이 많다.

#### 6.6 예외의 전파
- Java를 포함해서 대부분의 예외 처리에서는 예외가 호출처로 전파된다.

##### 예외 전파의 문제점
- 모든 함수의 소스코드를 보지 않으면 어떤 예외를 던질 가능성이 있는지 알 수 없다.
- 깜박하고 예외가 던져질 가능성을 놓치고 있다면 프로그램이 비정상 종료되어 버릴 수 있는 것이다.

##### Java의 검사 예외
- 자바에서는 다른 언어들이 '예외' 라고 부르고 있는 것을 다음과 같이 더 세분화 하고 있다.
- 1.예외 처리를 하지 않아도 되는 문제
- 2.예외 처리를 해도 좋은 실행시 예외
- 3.예외 처리를 해도 좋은 기타 예외

> 기타 예외는 검사 예외라고 불리며 만약 메소드 밖으로 던져지는 경우 throw 를 통해 명시해 주어야한다.

##### 검사 예외가 잘 사용되지 않는 이유
- 검사 예외는 매우 좋은 기능처럼 보이지만 다른 언어에서는 잘 사용되지 않는다.

> 귀찮기 떄문이다. throws나 try-catch 구문의 개수가 너무 방대해 지거나 어떤 메소드에서 던질 예외를 하나 추가하면 그 메소드를 호출하고 있는 메소드를 모두 수정해야 한다.

#### 6.7 정리
- 프로그램도 실패할 때가 있다.
- 실패를 전달하는 방법은 '반환값으로 알리는 방법', '실패하면 점프하는 방법' 이다.

> 신규 프로젝트 에서는 예외를 사용하는것이 좋다고 인정하고 있지만 현재 사용되는 코드는 예외 사용을 생각하지 안고 만들어져서 예외를 사용할 수 없는 것이다.

### 7 이름과 스코프

#### 7.1 왜 이름이 필요할까 ? 
- 우리는 물건이나 장소에 '알기 쉬운 이름' 을 붙여 그 이름을 이용해 가리키는게 보다 편하다.
- 프로그래밍도 마찬가지 이다. '12345 번지에 있는 것을 98765번지로 이동해' 라고 말하는것 보다
- '책상 위에 있는 봉투를 집 앞에 있는 우체통에 넣어' 라고 말하는 것이 더 편하다.

##### 어떻게 이름을 붙일까
- 컴퓨터가 이름과 물건을 대응 시키는 표를 가지고 있다면 가능하다.
```
{ 한국어 사전 => 36 번째책. 영어사전 => 37번째 책} ...
```

- 이와 같은 대응표가 있다면 사람이 '한국어 사전을 꺼내' 라고 명령해도, 컴퓨터는 '아 36번째 책 말이지' 라고 이해하게 된다.

##### 이름 충돌
- 초기 프로그래밍 언어에서는 대응표를 프로그램 전체에서 공유하고 있었다.
- 여기에는 큰 문제가 있었다.
- 동일한 이름이 충돌 될경우의 문제이다.
- 반복문에서 사용되는 변수와 비즈니스 로직이 수행되는 코드에서 변수명이 중복되게 된다면
- 심각할 경우 무한 반복이 되고 만다.

`이해를 돕기위한 예시 코드`
```java
for (int i = 0; i < 10; i++) {
    i = 0;
    ...
}
```

##### 충돌 피하기
- 프로그램 전체에서 하나의 대응표가 사용되고 있다.
- 즉 변수명이 유효한 범위가 프로그램 전체이다. 라는 상황을 이 변수는 전역 스코프 or 이것은 전역 변수다 라고 부른다.
> 전역 변수의 변경은 프로그램 전체에 영향을 미친다. 변수명이 중복되는것을 방지하려면 어떻게 해야할까?..

##### 긴 변수명을 사용한다.
- 긴 변수명을 사용하는 것이 하나의 방법이 될 수 있다.
- 변수명에 개발자의 이름을 넣거나, 연속 번호를 부여해서 중복되지 않도록 하는 방법 등이 있다.

##### 스코프를 이용한다.
- 사람이 변수명을 관리하고 있어야 해서 편리하지 못하다.
- 다른 한가지 대안으로 **스코프(scope)** 라는 개념이 탄생 했다.


#### 7.2 스코프의 진화
- 스코프(scope)란 이름의 유효 범위이다.
- 프로그램 전체에서 이름이 충돌하지 않도록 관리 하기위한 방법중 하나

##### 동적 스코프
`동작 방법 ?`
- 해결 방법중 하나는 함수 입구에 원래의 값을 기록해두고, 출구에서 원래의 값으로 되돌리는 것이다.
```perl
sub shori {
    $old_i = $i;
    $i = 0;
    $i = $old_i;
}
```

> 하지만 사람은 실수하는 생명체 이기 때문에 이런 작업도 컴퓨터에게 맡기고 싶다. 1991년 출시된 Perl4 부터는 변수를 Local로 선언하면 언어 처리계가 알아서 처리해 준다.

- 위와 같은 스코프를 동적 스코프 라고 한다.

`문제점`
- 동적 스코프는 조금 다루기 힘든 특징이 있다.
- **변수를 변경한 후 다른 함수를 호출한 경우 호출된 함수에 영향을 미친다.**
- 동적 스코프에서는 변경값이 호출되는 곳에 파급되기 때문에, 변수 값을 참조 했을 때 어떤 값이 될지는 호출처의 코드를 보지 않고선 알 수 없다.

##### 정적 스코프
- 전역 스코프나, 동적 스코프는 대응표를 프로그램 전역에 걸쳐 몇개의 함수가 공유하고 있다.
- **바뀐 값을 읽을 수 있지만 바뀌기 전의 값은 읽을수 없다.**

> 대응 표를 모두의 공용 공간에 두지말고, 함수가 호출될 떄 마다 새로운 대응표를 만들면 어떨까 ?

#### 7.3 정적 스코프는 완성체 인가 ?
- 지금은 많은 언어가 정적 스코프를 채택하고 있다.
- 하지만 완성체이진 않고, 아직 몇 가지 문제가 남아 있다.

- 1. 내포된것처럼 보이는 스코프가 실제로는 내포되어 있지 않다.
- 2. 내포한 스코프의 외부 변수를 변경할 수 없다.

#### 7.4 정리
- 이름의 유효범위는 2013년 기준 정적 스코프가 주로 사용되고 있다.
- 객체 지향에서 private 선언 등 접근 지시자도 접근 가능한 범위를 제한한다는 점에서 스코프가 닮았다.
- 스코프는 이해하기 쉬운 코드를 만들기 위한 핵심 개념으로 다양한 부분에서 계속적으로 사용되고 있다.

### 8. 형

#### 8.1 형 이란 ?
- 형은 사람이 데이터에 붙인 '추가데이터' 이다.
- 컴퓨터 안에 저장되어 있는 데이터는 On과 Off, 0과 1의 집합으로 표현되어 있다.
- On과 Off의 집합으로 수치 등의 여러 ㄱ밧들을 표현하고 비트열을 어떤 값으로 해석 하는지의 방법은 사람이 마음대로 정한 약속에 불과하다.
- **어떤 종류의 값으로 해석할지에 따라 틀린 값이 되어버리기 때문에 어떤 종류의 값인가? 라는 정보를 추가한것의 형의 시작이다.**

#### 8.2 수치를 On과 Off로 표현하는 방법
- 가장 간단한 방법은 3을 표현하기 위해선 3개의 램프를 켠다 이다.
- 하지만 이 방법은 표현하고 싶은 수 만큼의 램프가 필요하다.

##### 자릿수 발명
- 컴퓨터 탄생 1000년 이상 전에는 인류는 자릿수 기수법을 발명했다.
- 하나의 자리에 0에서 9까지 10가지 기호를 사용하여 수를 표현하는 방법이다.
- 자릿수를 사용함으로 999개에서 27개로 램프수를 많이 줄일 수 있었다.

##### 세그먼트 디스플레이
- 컴퓨터가 탄생하기 전에 하나의 자리를 7개의 램프로 표현할 수 있는 방법이 발명되었다.
- 계산기 등에서 수치를 표현하기 위해 자주 사용되는 세그먼트 디스플레이가 바로 그것이다.
- 세그먼트 디스플레이를 사용하면 7개의 램프로 한 자리수를 표현하기 때문에 3자릿수를 표현하기위해선 필요 램프갯수가 21개가 된다.

##### 주판
- 5개로 하나의 자리를 표현하는 방법으로 바로 주판을 사용하는 것이다.
- 주판의 표현 방법을 사용하면 5개의 램프로 한 자릿수를 표현할 수 있다.
- 3자릿 수를 표현하려면 15개의 램프가 필요하다.


#### 8.3 한 자리에 필요한 램프는 몇 개일까?
- UNIVAC I 등 초기 컴퓨터는 4개의 On/Off를 사용해서 수치를 표현했다.
- 이것을 사용하면 12개의 램프로 0 ~ 999까지 표현할 수 있다.

#### 8.4 실수는 어떻게 표현할까
- 예를 들어 16개 램프로 소수를 표현한다면 16개 중 10개의 램프로 0 ~ 1,023까지 표현할 수 있기 때문에 유효 숫자 3자리 정보를 표현할 수 있다.
- 나머지 6개 램프로 0~63까지 표현할 수 있기 때문에 이것을 소수점 위치 표현에 사용한다.

#### 8.5 형은 무엇을 위해 존재할까?
- 컴퓨터는 비트열 만으로 그것을 정수로 해석해야 할지 부동 소수점으로 해석해야 할지 알 수 없다.
- 이 값이 어떤 종류인지 정보가 별도로 필요하며 그것이 형이다.

##### 언어 처리계에 변수 종류를 알린다.
- 이 변수는 정수다 라고 알려서 사람이 아닌 컴퓨터가 기억해 두는 것이다.
- 이것이 변수형 선언이 탄생한 이유다.

#### 8.6 형의 다양한 전개

##### 사용자 정의형과 객체 지향
- C언어의 구조체 등이 대표적으로 언어가 가지고 있는 기본적인 형을 조합해서 새로운 형을 만드는 기능이 발명됬다.

> C++ 설계자인 Bjarne Stroustrup은 사용자가 정의할 수 있는 형이야 말로 프로그램을 구축하기 위한 기본요소라고 생각했다. 이런 형에 Class라는 이름을 붙였으며 이것이 제 2의 객체지향의 발명이다.

##### 총칭형, 제네릭스, 템플릿
- 다양한 형을 조합해서 만든 복잡한 형이 사용되면서, **일부만을 바꾸고 싶은데 전부 다시 정의해야 하는 것은 이상하다. 재사용하고 싶다.**는 필요가 생겨났다.

> 구성요소의 형을 일부만 바꾸는 형, 즉 총칭형이 등장했다. Java 제네릭 등이 그런 구조이다.

##### 형 추론
- 컴파일시에 형 체크는 하지만, 귀찮은 형 선언은 하고 싶지않다. 이를 위해 컴퓨터가 형을 추론하게 하는 접근이 있다.
- 최근에는 JVM상에서 동작 하는 언어인 Scala등 형 추론을 장점으로 부각시키는 언어가 늘고 있다.

#### 8.7 정리
- 현재는 정적 형결정과 동적 형결정과 같이 정보 저장 장소나 사용하는 타이밍이 다른 것 까지 포함해서 '형' 이라고 부른다.
- 이 때문에 형이 무엇인지 더욱 이해하기 어렵게 되었다.
- 어떤 정보가 어디에 있고 어떤 타이밍에 사용되는지의 관점에서 보면 조금은 이해하기 쉬울 것이다.

### 9. 컨테이너와 문자열

#### 9.1 다양한 종류의 컨테이너
- 언어에 따라 다양한 특성을 가진 상자가 사용된다.
- C언어의 배열, LISP의 리스트, Python의 튜플, Ruby의 어레이 등이 그들 이다.
- 같은 용어라도 언어에 따라 다른 의미로 사용되고 있다.
- LISP와 Haskell의 리스트는 Java와 Python의 리스트와 내부 구조가 완전히 다르다.

#### 9.2 왜 다양한 컨테이너가 존재할까 ?
- 각각의 컨테이너에는 장단점이 있기 때문이다.
- 컨테이너 종류에 따라 메모리 저장방법이 다르며, 그 차이에 따라 장단점이 생기게 된다.

##### 배열과 연결 리스트
- 배열에서는 순서대로 A, B, C 가 들어있다.
- 연결 리스트에서는 A를 넣은 다음 상자에 다음 값이 어디에 있는지의 정보가 들어 있다.
- 연결 리스트의 저장 구조가 2가지로 표현되지만, 양쪽 다 A, B, C 를 순서대로 읽어 들일 수 있다.

##### 배열에 값을 삽입하는 경우
- 얼핏보면 연결 리스트가 ㅂ사용하는 저장방법은 메모리를 2배 사용한느것처럼 보일 수 있다.
- 하지만 이것이 장점이 되기도 한다.
    - 요소를 삽입하는 시간이 빠르다.

> 배열에 요소를 삽입할 때는 삽입된 위치보다 뒤에 있는 요소를 전부 다른 위치로 옮겨야한다. (복사)


##### 연결리스트에 값을 삽입하는 경우
- 연결리스트에서는 메모리에 순서대로 정렬해있을 필요가 없다.
    - 다음 요소가 들어있는 위치를 메모리상에 넣어두기 때문이다.

> 요소 수가 많고 삽입이 빈번히 발생하는 경우에는 연결 리스트가 적합하다.

##### 연결리스트의 장단점
- 연결리스트의 장점은 삽입시 시간복잡도가 O(1)이다. (삭제시에도 동일)
- 단점은 n 항목에 있는 요소를 찾기위해서 시간이 필요하다.
    - 배열에서는 순서대로 데이터가 정렬되어 있기때문에 금방 알 수있지만
    - 연결리스트는 다음 번지수를 가리키고 있기때문에 해당 요소를 찾기위해서는 순차적으로 탐색을 해야한다.

#### 9.3 사전, 해쉬, 연상 배열
- 사전, 해쉬, 연상 배열로 불리는것들에 대해 알아본다.
- 통합해서 사전이라고 칭한다.
- 배열은 정수와 값을 대응시킨 반면, 사전은 문자열과 값을 대응시킨 것이다.
    - key, value 형태로 저장한다.

##### 해쉬 테이블
- 해쉬 테이블은 문자열을 인수로 받아서 정수를 반환하는 **해쉬 함수**를 사용해서 문자열과 값의 대응관계를 표현하는 방법이다.
- 값을 넣기 위해 큰 배열을 준비하고, 해쉬 함수를 사용해 문자열을 적당한 정수로 변환한뒤 해당 배열 어디에 저장할지 결정한다.

##### 트리
- 트리는 왼쪽자식, 오른쪽 자식 총 두개의 자식을 가지고 있다.
- 아래를 뻗어나가기 때문에 나무라기 보단 나무 뿌리처럼 보일 수 있다.

##### 요소를 꺼내는 시간
`트리의 경우`
- 트리의 경우 앞서 3개의 요소가 들어있는 트리를 구성했을때 이 트리에서 한개를 꺼내기 위해서는 최대 2회 비교가 필요하다.
- 트리는 높이가 하나 증가하면 요소수는 약 2배가 된다.
- 데이터량이 2배가 될 때 마다 필요한 비교 횟수가 1회 증가한다.
- 시간복잡도는 O(log n)이다.

`해쉬테이블의 경우`
- 키에 대응을 하는 값을 꺼내기 위해선 '키를 해쉬함수로 변환', '배열의 해당 장소에 있는 값읽기' 작업이 필요하다.
- 이 작업은 데이터량과 관계없이 O(1) 이다.

> 해쉬 테이블의 시간복잡도가 가장 작다. 많은 언어가 사전을 만들기 위해 해쉬테이블을 사용하고 있는 근거이다. 메모리 소비량으로 따져봤을 때에는 배열에 넣는 방법ㅇ ㅣ가장 작다.

##### 만능 컨테이너란 없다.
- 어떤 목적이든 사용할수 있는 최선의 컨테이너는 없다.
- 컨테이너는 사용하는 목적, 어떤 사용법을 적용할 것인가, 등 에 따라 최적의 컨테이너도 달라진다.


#### 9.4 문자란 ?

##### 문자 집합과 문자 부호화 방식
- 한국에서는 한글을 문자라 생각하고, 일본에서는 히라가나, 카타가나, 한자로 문자라고 생각할 것이다.
- 문자란 결국 인간이 **이것은 문자라고 부르자** 라고 정한 기호 집합에 불과하다.

##### 컴퓨터 이전 시대의 부호화
- 모스부호에서는 짧은 가격을 On 하는것과 그 간격의 3배를 On으로 한것의 조합으로 문자를 표현하고 있다.

##### 보 코드
- 모스 부호는 사람이 스위치를 눌러 송ㅅ니하고, 사람이 귀로 들어 수신한다는 규칙으로 만들어진 부호화 방법 이었다.
- 이 방법은 1초 동안 송신할 수 있는 양과 수신할수 있는 양에 한계가 있다.
- 이를 보안하기 위하 등장한 것이 텔레타이프 단말기다.
- 타자기가 전화선에 연결되어 있는 모양으로 , 키보드를 눌러 문자를 입력하고 수신자는 수신한 문자를 프린터로 출력할 수 있었다.
- 이후 펀치 테이프와 가독기를 연결하여 사용하게 되었다.

##### EDSAC 문자 코드
- 1949년에 만들어진 EDSAC 종이 테이프를 입력에 사용했다. 보 코드와 같은 발상이다.

##### ASCII, EBCDIC
- EDSAC이후 다양한 컴퓨터가 만들어 졌고, 문자 부호화방식도 제각각 이었다.
- 이 때문에 어떤 컴퓨터에서 출력한 문자열을 다른 컴퓨터에서 읽으려면 일일이 변환 작업을 거쳐야 했다.
- 이를 보다 편하게 하기 위해 표준화한 방법이 바로 ASCII 이다.

##### Unicode에 의한 통일
- 전 세계의 문자를 부호화 하는 방벙을 만들자는 움직이 시작 되었다.
- 1984년에 국제 표준화 기구가 표준화 작업을 시작했고, 1993년에 표준이 되었다.

#### 9.5 문자열이란?
- 문자열이란 문자가 정렬해 있는 것이다.
- 하지만 문자에 따라선 문자열을 표현하는 방법은 제 각각이다.

##### 길이 정보를 가지고 있는 Pascal문자열, 가지고 있지 않은 C 문자열
- C언어와 Pascal은 둘다 하나의 문자를 8비트로 저의하고 있다.
- Pascal은 제일 앞 부분에 문자열 길이를 기록해 두고, C문자열은 문자열이 시작되는 메모리상의 위치만을 가지고 있다.

##### NUL 문자로 문자열의 끝을 표햔한다.
- C언어에서는 문자열의 끝을 표현하는 특별한 문자를 사용한다.
- NUL문자는 0에 대응하는 문자로 코드에서는 \0으로 표현한다.

##### 한 문자가 16비트인 Java 문자열
- Java 문자열도 길이 정보를 가지고 잇다.
- char 형이 16비트로 정해져 있다.
- 문자에 대한 정의가 다른것이다.
- 자바의 문자란 0~65,535로 표현할수 있는 유니코드의 한 문자인 것이다.

#### 9.6 정리
- 어떻게 메모리에 저장하느냐에 따라 성능 차이가 난다는것과, 어느쪽이 일방적으로 뛰어 나느것이 아닌 각각의 장단점이 있다.

### 10 병행처리

#### 10.1 병행 처리란 ?
- 복수의 처리를 시각축 상에 오버랩에서 실행하는 것을 병행처리라고 한다.
- 편리한 병행 처리를 위해 프로세스나, 스레드 등의 개념이 만들어 졌다.
- 또한 병행 처리가 원인이 되어 새로운 문제를 일으키게 되자 그 대안으로 락 이나 파이버 등의 개념이 발명되었다.

#### 10.2 잘게 분할해서 실행한다.
- 한번에 하나의 처리를 하는것보다 복수 개의 처리를 동시에 실행하는 것이 편리하다.
- 실행하기 위한 회로가 하나뿐인데 복수의 처리를 동시에 실행할 수 있는 이유는 다음과 같다.

> 사람이 눈치챌수 없는 짧은 순간에 복수의 처리를 변경해가면 실행한다.

`이것이 병행처리의 가장 핵심 개념이다. 잘게 분할해서 실행되고 있는것이다.`

#### 10.3 처리를 변경하는 2가지 방법
- 하나의 실행 회로를 사용해서 복수의 처리를 실행하는 것을 사람에 비유하면 하나의 일인용 게임기를 둘이서 번갈아 사용하는것과 같다.
- 여기서 **언제 교대할 것인가**를 정하는 방법은 크게 2가지로 나눌수 있다.

##### 협력적 멀티태스크
- '타이밍이 좋은 시점에 교대' 하는 방법
- 처리가 일단 락되는 시점에 자발적으로 교대를 하는 방법
- 이런 방법을 협력적 멀티 태스크라고 한다.
- 어떤 처리가 '교대해도 좋아' 라고 말하지 않는 다면 계속해서 대기 해야한다는 문제점이 있다.

##### 선점적 멀티태스크
- '일정 시간에 교대' 하는 방법
- 개별 프로그램과 입장이 다른 태스크 스케쥴러가 존재한다.
- 일 정시간마다 지금 실행되고 있는 처리를 강제적으로 중단시켜 다른 프로그램이 실행될 수 있게 한다.
- 이런 방법을 선점적 멀티태스크 라고 한다.
- 처리를 멈출수 있는 프로그램의 협력 없이도 강제적으로 처리를 중지시킬 수 있는것이 특징이다.

#### 10.4 경합 상태 방지법
- 선점적 멀티태스크는 프로그램을 사용하는 입장에서는 매우 좋은 방법이다.
- 하지만 프로그램을 개발하는 입장에서는 또 다른 문제가 발생한다.
```
예금잔고가 10,000원 이상이면 {
    예금 잔고를 10,000원 줄이고
    10,000 원 지폐를 출금하라.
}
```
- 위와 같은 프로그램 자체만으로는 아무런 문제가 없어 보인다.
- 하지만 예금 잔고 변수를 공유하고 있는 상태라면 복수 개 프로그램이 실행되었을때
- 2만원을 출금하게되는 상황이 발생할 수 있다.
- 이런 현상을 경합상태 (Race Condition) 혹은 스레드 세이프(Thread Safe) 하지 않다고 표현한다.

##### 경합 상태의 3가지 조건
- 1.2가지 처리가 변수를 공유하고 있다.
- 2.적어도 하나의 처리가 그 변수를 변경한다.
- 3.한쪽 처리가 한 단락 마무리 되기 전에, 다른 한쪽의 처리가 끼어들 가능성이 있다.

> 역으로 말하면 이 3가지 조건중 하나라도 제거할 수 있따면 병행 실행시에도 안정된 프로그램을 만들 수 있다.

##### 공유하지 않는다 - 프로세스와 액터 모델
- 처음 부터 아무것도 공유하지 않는다면 1번 조건은 발생하지 않기 때문에 경합 상태를 신경 쓸 필요가 없다.

##### 프로세스에서는 메모리를 공유하지 않는다.
- UNIX에서는 실행 중의 프로그램을 **프로세스** 라고 부른다.
- 서로 다른 프로세스는 메모리를 공유하지 않는다.
- 데이터베이스 접속, 파일 읽고 쓰기 등 무엇인가를 공유 했을때만 조심하면 된다.

##### 공유하지 않는 접근법은 성공했을까 ?
- UNIX 출시후 약 10년뒤 경량 프로세스가 만들어진다.
- 메모리를 공유하지 않는 것은 너무 엄격한 구조 였다.
- 이것이 나중에 **스레드** 라고 불리게 되었다.

> 아무것도 공유하지 않는다는 접근법에서는 해결되지 않는 문제가 있다. 현재도 스레드를 사용해서 공유 메모리를 어떻게 다뤄야 할지 고심해가면서 프로그램이 만들어지고 있다.

##### 액터 모델
- '메모리를 공유하지 않는다' 는 설계 방침에서의 또 다른 흐름이 바로 액터 모델이다.
- 1973년에 발표된 병행 처리를 표현하기 위한 모델이다.
- 병행해서 동작하는 복수의 처리가 정보를 교환하는 방법으로 '메모리를 공유한다'가 아닌 '메시지를 보낸다' 이다.

```
1. B라는 사람은 A라는 사람에게 작업을 부탁하기위해 데스크가 아닌 A의 서류상자에 넣어둔다.
2. B라는사람은 A라는 사람에게 부탁한 작업이 언제 끝날지 모른다.
3. B라는 사람은 A가 작업을 완료한 뒤 자신의 서류상자에서 완료된 작업을 확인한다.
```
> 처리는 비동기로 이루어 진다. 이런 특징이 잘 맞는 처리가 메시지 교환이다. Twitter, Facebook 등 대량의 사용자 메시지를 취급하는 서비스 에서는 이 액터 모델이 적합한 처리가 많다.


##### 변경하지 않는다 - const, val, Immutable
- '메모리를 공유해도 변경하지 않으면 문제가 없다'에 대한 대응책도 존재한다.
- 이 방식을 강하게 어필하고 있는 언어로, 모든 값이 변경 불가능한 Haskell 등이 그 예이다.

> 한편 보다 현실적인 타협안으로 일부 변수만 변경하지 못하도록 제공한다. const, val 등..

##### 끼어들지 않는다.
`협력적 스레드의 사용`
- 파이버나, 코루틴, 그린 스레드 등으로 불리는 기법을 사용하는것이다.
- 스레드가 선점성을 가지고 끼어드는 원인이 되기 때문에 협력적 스레드를 만들면 된다는 생각이다.

> Python 이나 JavaScript의 제너레이터가 그 예이다.

`끼어들면 곤란해지는 처리에 표식을 붙인다`
- 다른 방법은 **지금 끼어들면 곤란해**라는 표식을 고유하는 것이다.
- 어떤 메모리 값이 0이 아니면 이것은 **다른 스레드가 끼어들면 곤란한 처리를 하고 있어** 라고 정해 두는 것이다.
- 우선 해당 메모리 값을 체크한다. 그 값이 0이명 처리를 실행해도 좋고, 0이 아니면 0으로 바뀌기까지 기다렸다가 처리를 한다.

> 이 방법에는 여러가지 기법이 있다. 락, 뮤텍스, 세마포어 등 다양한 명칭이 있다.

#### 10.5 락의 문제점과 해결책

##### 락의 문제점
- 이렇게 쉬워진 락도 아직 어려운 문제를 가지고 있다.

##### 교착상태가 발생한다
- 교착상태 (DeadLock) 이라고 불리는 현상이다.
- 이 문제를 방지하기 위해 프로그래머는 프로그램 전체에서 락의 순서가 일관되도록 주의 해야한다.

> 무엇에 락을 걸어야 하는가 뿐 아니라, 어떤 순으로 락을 걸어야 하는가도 파악해야 한다.

##### 합성할 수 없다
- 락에는 '합성할 수 없다'는 문제점이 있다.
- 하나의 묶음 (아토믹) 으로 처리를 해야할때 어떤 락을 걸면 좋을까
- 스레드 세이프 라이브러리에는 락 제어를 프로그래머가 챙기지 않아도 되도록, 내부에서 락을 사용해 꺼내는 처리나 추가하는 처리가 끼어들지 못하도록 한다.
- 하지만 이 락으로는 꺼내는 처리와, 추가하는 처리 사이에 끼어드는 것을 막을 수는 없다.

##### 트랜잭션 메모리
- 이 문제를 해결하려고 하는것이 트랜잭션 메모리 기법이다.
- 데이터베이스의 트랜잭션 기법을 메모링 ㅔ저ㅏㄱ용한 것이다.

> 실험적으로 해보고, 실패하면 처음부터 다시 고쳐서하고, 성공하면 변경을 공유한다.

- 직접 변경하는 것이 아닌 **일시적으로 별도 버전을 만들어 그것을 변경하고 하나의 묶음 처리가 끝나면 반영**하는것이 포인트다.

#### 10.6 정리
- 병행 처리는 옛날부터 많은 사람을 고생시킨 문제로, 아직까지 많은 사람을 고민하게 만들고 있다.
- 역사를 따라가 보면 공유 -> 비공유 -> 공유, 협력 -> 비협력 -> 협력, 하드웨어 -> 소프트웨어 -> 하드웨어 같이 마치 결정하지 못하고 2가지 방법 사이에서 방황하고 있는듯 보인다.
- 한쪽만 배우지 말고 양쪽 모두 익혀서 균형 있게 사용하는 것이 바람직하다.

### 11 객체와 클래스

#### 11.1 객체 지향이란?

##### 객체는 현실 세계의 모형
- 우리가 컴퓨터로 문제를 해결하고 있을 때, 현실 세계의 사물 모형을 컴퓨터 안에 만들 필요가 있다.

##### 클래스란?
- C++에서는 사용자가 정의할 수 있는 형 이라고 할수 있따.
- 대부분의 언어에서 프로그램을 만들 때 클래스는 필수 조건이 아니다.
- Java 에서는 **클래스라는 부품을 정의하고, 그것을 조립해 나가는 것이 프로그래밍 이다.**

#### 11.2 변수와 함수를 합쳐서 모형을 만드는 법
- 프로그래머에겐 '하나로 모아 모형을 만들고 싶다'는 목적이 있다.
- C++, Java 등이 채용한 클래스가 유명하지만 우선 이외의 방법을 먼저 살펴본다.

`모듈(Module)`
- 이것은 원래 관련된 함수를 하나로 모아두기 위한 기능 이었다.
- Perl에서는 비슷한 기능이 패키지 라고 불린다.

`함수, 변수 동이랗게 해쉬에 넣는 방법`
- 이것은 JavaScript 드으이 언어가 채용하고 있다.

`클로저(Closure)`
- 함수 실행시 이름의 공간의 변수를 하나로 묶기 위해 사용하는 방법이다.
- 주로 함수형 언어에서 사용되는 방법이다.

#### 11.3 모듈, 패키지

##### 모듈, 패키지란 무엇인가?
- 관련성이 높은 함수나 변수의 묶음을 명시하기 위해 모듈이라는 개념이 도입 되었다.
- Python, Ruby 에서는 모듈이라 하고, Java, Perl에서는 패키지 라는 이름으로 불린다.

#### 11.4 함수도 해쉬에 넣는다

##### 퍼스트 클래스
- JavaScript가 도입하고 있는 다른 한 가지 방법은 함수도 해쉬에 넣는다는 접근법이다.
- 제한이 없는 '변수에 대입한다, 함수의 인수로 전달한다, 함수의 반환값으로 전달한다' 등이 가능한 값을 **퍼스트 클래스(First Class)**

> 일급 시민 을 의미한다. 최근의 언어 Java 등에서 문자열은 퍼스트 클래스 값이다.

- JavaScript에서는 함수도 퍼스트 클래스 값이다.
- 함수를 변수에 대입하거나 함수의 반환값으로 전달하는 것도 가능하다.

##### 함수를 해쉬에 넣는다.
- JavaScript의 해쉬는 다음과 같은 구문으로 만들어진다.
```javascript
{counter: 0, name: "참새"};
```
> 0이나, "참새" 등 값이 들어 있는 부분에 함수를 넣을 수 도 있다.

#### 11.5 클로저

##### 클로저란 ?
- 클로저(Closure)도 많은 사람들이 이해하기 어려운 개념 중 하나다.
- 이것은 객체적인 것을 만들기 위한 기술이다.

> 클로저라는 특수한 구문이 있는것은 아니다. 함수를 함수 안에 정의하고 내포할수 있는 정적 스코프가 있어서 함수를 반환값으로 사용하거나 변수에 대입하여 사용한다는 개념이다.

##### 왜 클로저라고 부를까?
- 클로저라는 명칭에서 무언가를 닫는다는 느낌이 든다.
- 왜 클로저 라고 부를까 ?

> 자유 변수를 포함한 식으로 '열린 식' 이라 부르고, 그 자유 변수의 바인딩을 조합함으로 해당 식을 닫고 있기 때문이다.

#### 11.6 클래스

##### Hoare가 생각한 클래스
- 현실 세계의 사물은 편의사 ㅇ상호 배타적 종류로 분류될 수 있따고 기술하고 있다.
- 그에 클래스는 분류였다.
- C++, Java에서 사용하는 클래스 라는 개념은 여러가지 의미가 추가되어 복잡하지만, 처음 시작은 분류 였다.

##### C++ 클래스
- 클래스는 타입(Type)이다. 이것이 C++을 이루는 아주 중요한 원리다.
- C++에서 클래스가 사용자 정의 타입을 의미한다면 왜 그것을 type이라고 부르지 않는가?

##### 사양으로서 역할
- C++에게 있어서 클래스란 사양을 표명한 것이기도 했다.
- 즉 클래스는 객체가 어떤 메소드를 갖고 있고, 어떤 메소드를 가족 있지 않은가 라는 사양을 선언하는 역할도 했다.

> 메소드의 호출은 메시지를 객체에게 전달하는 것이며, 그 메시지를 받은 객체가 어떤 동작을 할지는 수신 객체가 자유롭게 결정할 수 있다. 이런 자유가 객체지향의 중요한 요소이다.

##### 클래스의 3가지 역할
- 1.결합체를 만드는 생성기
- 2.어떤 조작이 가능한지에 대한 사양
- 3.코드를 재사용하는 단위


#### 11.7 정리
- 객체 지향이 현실 세계의 사물 모형을 만들기 위해 만들어 졌다.
- 언어마다 구현 방법이나 '객체 지향' 이 의미하는 바가 다르다.

### 12 상속을 통한 재사용

#### 12.1 상속이란?
- 클래스의 가장 기본적인 의미는 분류 이다.
- 어떤 클래스에서 선언된 것은 그것을 세분화한 '자식 클래스' 에게도 자동으로 이어지는것이 좋다.
- 이것이 **상속** 이다.

##### 상속에 관한 다양한 접근법
- 상속은 크게 3가지 측면으로 접근할 수 있다.

##### 일반화.특수화
- 첫 번째는 부모 클래스로 일반적인 기능으로 구현하고, 자식클래스로 목적에 특화된 기능을 구현한다'는 접근이다.

> 자식 클래스는 부모 클래스를 특수화한다 는 설계 방침이다.

##### 공통 부분을 추출
- 두 번째는 '복수 클래스의 공통 부분을 부모 클래스로서 추출하면 좋다' 는 접근법이다.

##### 차분 구분
- 세번째는 '상속 후 변경된 부분만을 구현하면 효율이 좋다' 는 접근 법이다.

> 상속을 재사용을 위해 사용함으로 구현이 편해질 수 있다는 발상이다.

##### 상속은 양날의 칼
- 여러 가지 사용법이 있다는 것은 상속이라는 시스템이 높은 자유도가 있다는 것을 의미한다.
- '상속을 많이 사용하면 코드가 복잡해 진다, 제어를 추가해야 한다' 는 의견이 많다.

> 상속을 사용해서 코드를 재사용하면 코딩량이 줄어 편하다. 하지만 반복한다면 코드 영향 범위가 넓어져 이해하기 어렵게 된다. 따라서 상속 트리의 깊이를 낮추는 것이 중요하다.

##### 리스코프 치환 원칙
- CLU라는 언어의 설계자인 Liskov가 1987년에 제창한 것으로, 자식 클래스를 만들 때 주의해야 할 사항으로 자주언급되는 것이 **리스코프 치환 원칙** 이다.

> 어떤 클래스 T의 객체에 대해 항상 성립하는 조건이 있다면, 그 조건은 자식 클래스 S의 객체에서도 항상 성립해야만 한다.

#### 12.2 다중 상속

##### 하나의 사물을 복수로 분류
- 현실 세계의 사물은 하나의 분류에만 해당된다고 단정할 수 없다.
- 현실 세계에서 하나의 사물이 복수의 분류에 해당하는 경우가 있기 때문에 그것을 모델화하는 프로그래밍 언어가 복수의 클래스를 상속할 수 있어야 한다.

#### 12.3 다중 상속의 문제점 - 거듭되는 충돌
- 다중 상속은 편리한 기능이다.
- 복수의 부모 클래스가 같은 이름의 메소드를 가지고 있다면 이름 문제가 발생한다.

##### 해결책 1 다중 상속을 금지한다.
- Java는 클래스 다중 상속을 금지 했다.
- 다중 상속을 버림으로 문제를 해결 했지만, 대신 다중 상속의 편리함 또한 버리게 된다.

> 이를 포함해서 Java에서는 '코딩시 재사용을 목적으로 한 상속'을 피하려고 하는 움직임을 보이고 있다.

##### 위임
- 대신하여 발달한것이 '위임(Delegation) 개념이다.' 사용하고 싶은 코드를 가지고 있는 클래스 객체를 만들고, 필요에 따라 해당 클래스에 처리를 맡기는 방법이다.

> 이임의 참조도 소스에 하드코딩 하는것이 아닌, 설정 파일을 사용해서 실행 시에 주입하는 것이 편리하다. 이런 발생으로 의존성 주입 (Dependency Injection) 이  탄생했다.

##### 인터페이스
- Java는 다중 상속을 금지하고 있지만 Java에서 Interface 다중상속은 허용을 하고 있다.
- 인터페이스는 코드를 가지고 있지 않은 클래스 이다.
- 인터페이스를 상속한 클래스는 반드시에 xx 라는 이름의 메소드를 가지고 있다는 사양만 가지고 있다.

> Java는 사양만 다중 계승될 수 있도록 인터페이스를 도입했다.


##### 메소드 해결 순서를 고민한다
- '어떤 순서로 탐색하면 좋을지 명확히 정의하면 되지 않을까?' 라는 접근법을 가진 언어도 있다.

> 자신이 모른다면 앞에 쓰여있는 부모부터 순서대로 확인한다 (깊이 우선 탐색) 으로 해결이 될까 ?

##### 깊이 우선 탐색의 문제점
- Base 클래스를 복수의 클래스 Derived1, Derived2 가 상속 받고 있다고 하고, 이 두 클래스를 상속받는 Multi 가 있다고 가정하자.
- 이런 구조를 '마름모 상속' 이라고 한다.
- 일부러 x를 재정의 했지만, 전혀 영향을 주지 못하게 된다.

> Python 2.3 부터는 이 문제를 피하기 위해 C3 선형화를 사용하고 있다.

##### C3 선형화로 순서를 정한다.
- C3 선형화는 1996년에 제안된 알고리즘으로 2가지 제약조건을 만족하도록 클래스에 순서를 매겨 정렬한다.
    - 부모 클래스는 자식 클래스보다 먼저 탐색되지 않는다.
    - 어떤 클래스가 복수의 부모 클래스를 상속하고 있으면 먼저 만들어진 것이 우선된다.

> 재정의 한것이 원래대로 돌아가는 것의 문제의 원인은 부모 클래스가 자식 클래스 보다 먼저 탐색되기 때문이다.
