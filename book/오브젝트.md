# 오브젝트

오브젝트 스터디 대비 정리




## 서론



### 프로그래밍 패러다임이 중요한 이유 ?



개발자 공동체가 동일한 프로그래밍 스탈와 모델을 공유할수 있게 함으로써 불필요한 부분에 대한 의견 충돌을 방지한다.

동일한 규칙와 방법을 공유하는 개발자로 성장할 수 있도록 준비시킬 수있다.



프로그래밍 패러다임은 두 가지이상 패러다임이 공존할 수 있다.

하나의 언어내에서 공존함으로써 서로의 단점을 보완한다.

대표적인 예로 C++ (절차지향 + 객체지향), Scala(함수형 + 객체지향) 가 있다.

이 처럼 하나 이상의 패러다임을 수용한 언어를 다중패러다임 언어 라고 한다.



> 프로그래밍 패러다임은 혁명적 (revolutionary) 인 것이 아닌, 발전적 (evolutionary) 인 것이다.



'은총알은 없다' 라는 프레디 브룩스의 말을 기억하라. 객체지향이 적합하지 않다면 언제라도 다른 패러다임을 적용할 수 있는 시야를 기르고 지식을 갈고 닦아야 한다.





## 1장 객체, 설계





### 티켓 판매 애플리케이션



티켓 판매 애플리케이션 구현에 앞서 요구사항을 정의해 보자.



연극이나, 음악회를 공연할 수 있는 소극장을 운영중이다.

소극장을 홍보하기 위해 작은 이벤트를 기획하였다.

이벤트에 당첨된 관람객과, 일반 관람객은 각자 다른 방식으로 입장 시켜야한다.

- 이벤트 당첨 관람객은 초대장을 **티켓으로 교환** 한 뒤 입장을 해야한다.
- 당첨되지 못한 관람객은 **티켓을 구매** 한 뒤 입장을 해야한다.



`초대장 클래스`

````java
class Invitaion {
  private LocalDateTime when;
}
````



`티켓 클래스`

````java
class Ticket {
  private Long fee;
}
````



`소지품 클래스`

```java
class Bag {
  private Long amount;
  private Invitation inviation;
  private Ticket ticket;
  
  public Bag(long amount) {
    this(nul, amount);
  }
  
  public Bag(Invitation inviation, long amount) {
    this.inviation = invaition;
    this.amount = amount;
  }
  
  // ==  비즈니스 메소드 ==//
  public boolean hasInvitation() {
    return invitation != null;
  }
  
  public boolean hasTicket() {
    return ticket != null;
  }
  
  public void setTicket(Ticket ticket) {
    this.ticket = ticket;
  }
  
  public void minusAmount(Long amount) {
    this.amount -= amount;
  }
  
  public void plusAmount(Long amount) {
  	this.amount += amount; 
  }
}
```



`관람객 클래스`

````java
class Audience {
  private Bag bag;
  
  public Audience(Bag bag) {
    this.bag = bag;
  }
  
  public Bag getBag() {
    return bag;
  }
}
````



> 관람객은 소지품에 초대권, 티켓, 현금을 가질 수 있다.
>
> 관람객이 입장하기 위해서는 초대권 혹은 현금을 가지고 있어야한다.
>
> 따라서 소지품 클래스 생성시 초대권 혹은 현금을 가질수 있도록 생성자를 이용하여 제약조건을 추가하였다.



`매표소 클래스`

````java
class TicketOffice {
  private Long amount;
  private List<Ticket> tickets = new ArrayList<>();
  
  public TicketOffice(Long amount, Ticket ... tickets) {
    this.amount = amount;
    this.tickets.addAll(Arrays.asList(tickets));
  }
  
  public Ticket getTicket() {
    return tickets.remove(0);
  }
  
  public void minusAmount(Long amount) {
    this amount -= amount;
  }
  
  public void plusAmount(Long amount) {
    this.amount += amount;
  }
}
````



`판매원 클래스`

````java
class TicketSeller {
  private TicketOffice TicketOffice;
  
  public TicketSeller(TicketOffice TicketOffice) {
    this.TicketOffice = TicketOffice;
  }
  
  public TicketOffice getTicketOffice() {
    return ticketOffice;
  }
}
````



`소극장 클래스`

````java
class Theater {
  private TicketSeller ticketSeller;
  
  public Theater(TicketSeller ticketSeller) {
    this.ticketSeller = ticketSeller;
  }
  
  public void enter(Audience audience) {
    if (audience.getBag().hasInvitation()) {
      Ticket ticket = ticketSeller.getTicketOffice().getTicket();
      audience.getBag().setTicket(ticket);
    } else {
			Ticket ticket = ticketSeller.getTicketOffice().getTicket();
      audience.getBag().minusAmount(ticket.getFee());
      ticketSeller.getTicketOffice().plusAmount(ticket.getFee());
      audience.getBag().setTicket(ticket);
    }
  }
}
````





### 소프트웨어 모듈의 3가지 목적

- 실행 중에 제대로 동작해야 한다.
- 변경을 위해 존재하는것. 변경하기 어려운 모듈은 제대로 동작 하더라도 개선해야 한다.
- 코드를 읽는 사람과 의사소통하는것. 특별한 훈련 없이도 개발자가 쉽게 읽고 이해할 수 있어야 한다.





### 문제점



관람객과 판매원이 소극장의 통제를 받는 **수동적인 구조** 이다.



이해 가능한 코드란 우리의 예상에서 크게 벗어나지 않는 코드이다.

위의 구조에서는 소극장이 관람객의 가방을 뒤져 초대권을 확인 한뒤, 판매원의 티켓을 가져와 지급한다.

또한 이 코드는 여러 가지 세부적인 내용들을 한꺼번에 기억하고 있어야 한다.

관람객이 가방을 가지고 있고, 가방에는 현금과 티켓이 들어 있으며, 판매원이 오피스에서 티켓을 판매하고... 이런 사실들을 모두 기억하고 있어야 한다.



> 하나의 클래스나 메서드에서 너무 많은 일을 하기 때문에 문제가 된다.
>
> 가장 심각한 문제는 관람객이나, 판매원이 변경될 경우, 소극장의 코드도 영향을 받는다는 점이다.



객체 사이의 의존성 (dependency) 와 관련된 문제이다.

의존성은 변경에 대한 영향을 암시한다. 그렇다고 객체 사이의 의존성을 완전히 없애는 것은 답이 아니다.

**최소한의 의존성만 유지** 하고 불필요한 의존성을 제거하는 것이다.



객체 간의 의존성이 과한경우 **결합도 (coupling)** 가 높다고 말한다.





### 설계 개선하기



코드를 이해하기 어려운 이유는 소극장이 **관람객의 가방과 매표소에 직접 접근** 하기 때문이다.

소극장이 관람객과 판매원에 대해 세세한 부분까지 알지 못하도록 변경하면 된다.

관람객과 판매원을 **자율적인 존재** 로 만들자.



`소극장 클래스`

````java
class Theater {
  private TicketSeller ticketSeller;
  
  public Theater(TicketSeller ticketSeller) {
    this.ticketSeller = ticketSeller;
  }
  
  public void enter(Audience audience) {
    ticketOffice.sellTo(audience);
  }
}
````



`판매원 클래스`

````java
class TicketSeller {
  private TicketOffice ticketOffice;
  
  public TicketSeller(TicketOffice ticketOffice) {
    this.TicketOffice = ticketOffice;
  }
  
  public void sellTo(Audience audience) {
  	ticketOffice.plusAmount(audience.buy(ticketOffice.getTicket()));
  }
  
  // == 제거 == //
  public TicketOffice getTicketOffice() {
    return ticketOffice;
  }
  // == == //
}
````



`관람객 클래스`

````java
class Audience {
  private Bag bag;
  
  public Audience(Bag bag) {
    this.bag = bag;
  }
  
  public Long buy(Ticket ticket) {
    if (bag.hasInvitation()) {
      bag.setTicket(ticket);
      return 0L;
    } else {
      bag.minusAmount(ticket.getFee());
      bag.setTicket(ticket);
      return ticket.getFee();
    }
  }
  
  // == 제거 == //
  public Bag getBag() {
    return bag;
  }
  // == == //
}
````



소극장은 더이상 관람객과, 판매원에게 개입하지 않는다.

관람객과 판매원 역시 서로간의 대화를 통한 **자율적인 객체**가 되었다.



> 중요한 점은 관람객이나 판매원의 내부 구현이 변경되더라도 서로에게 영향을 주지 않는다.
>
> 수정된 코드는 변경 용이성 측면에서도 확실히 개선 되었다.





### 캡슐화와 응집도



핵심은 객체 내부의 상태를 캡슐화하고 **객체 간에 오직 메시지 (대화) 를 통해서만 상호작용 하도록 만드는 것** 이다.

밀접하게 연관된 작업만을 수행하고 연관성 없는 작업은 다른 객체에게 위힘하는 것을 가리켜 **응집도 (cohesion)** 가 높다고 말한다.





### 절치지향과 객체지향



소극장의 enter() 메소드는 **프로세스 (process)** 이며, 관람객, 판매원, 티켓 등은 **데이터 (Data)** 이다.

개선전 소극장의 enter() 메소드 처럼 프로세스와 데이터를 별도의 모듈에 위치시키는 방식을 **절차적 프로그래밍(Procedural Programming)**

데이터와 프로세스가 동일한 모듈 내부에 존재하는 것을 **객체지향 프로그래밍 (Object-Oridented Programming)** 이라고 한다.



> 절치적 프로그래밍은 일반적으로 우리의 예상을 벗어나기 때문에 쉽게 읽지 못하는 코드일 확률이 높으며, 변경에 취약하다.
>
> 반면, 객체지향 프로그래밍은 객체를 **자율적인 존재**로 만들기 때문에 보다 이해하기 쉽고, 변경에 유연하다.





### 책임의 이동



절차적 프로그래밍과 객체지향 프로그래밍의 근본적인 차이를 만드는것은 **책임의 이동 (shift of responsesibility)** 이다.

절차적 프로그래밍은 소극장 (Threater) 에게 **책임이 집중**되어 있고, 객체지향 프로그래밍은 각 객체에게 **책임이 적절히 분배**되어 있다.

객체는 다른 객체와의 협력 안에서 특정한 역할을 수행하는 데 필요한 적절한 책임을 수행해야 한다.



> 설계를 어렵게 만드는 것은 **의존성**이다.
>
> 좋은 설계는 불필요한 의존성을 제거함으로 써 객체간의 **결합도**를 낮춰야한다.
>
> 이전 코드에서 선택한 방법은 각 객체 내부로 감춰 **캡슐화** 하는 방법을 사용했다.
>
> 캡슐화는 객체의 **자율성**을 높이고 **응집도** 높은 객체를 만드는 방법이다.





### 추가 개선하기



현재 설계는 이전보다 분명히 좋아졌지만, 아직 개선의 여지가 있다.



`소지품 클래스`

````java
class Bag {
  private Long amount;
  private Ticket ticket;
  private Invitation inviation;
  
  public Long hold(Ticket ticket) {
    if (hasInvitation()) {
      setTicket(ticket);
      return 0L;
    } else {
      setTicket(ticket);
      minusAmount(ticket.getFee());
      return ticket.getFee();
    }
  }
  
  private void setTicket(Ticket ticket) {
    this.ticket = ticket;
  }
  
  private boolean hasInvitation() {
    return invitation != null;
  }
  
  private void minusAmount(Long amount) {
    this.amount -= amount;
  }
}
````



`관람객 클래스`

````java
class Audience {
  public Long buy(Ticket ticket) {
    return bag.hold(ticket);
  }
}
````



`매표소 클래스`

````java
class TicketOffice {
  public void setTicketTo(Audience audience) {
    plusAmount(audience.buy(getTicket()));
  }
  
  private Ticket getTicket() {
    return tickets.remove(0);
  }
  
  private void plusAmount(Long amount) {
    this.amount += amount;
  }
}
````



`판매원 클래스`

````java
class TicketSeller {
  public void sellTo(Audience audience) {
    ticketOffice.sellTicketTo(audience);
  }
}
````



추가 개선이후, 각 객체들이 좀 더 자율적인 존재가 되었지만, 만족스러운 상황은 아니다.

그 이유는 변경 전에는 존재하지 않았던 **새로운 의존성 (매표소와 관람객)** 이 생겨났기 때문이다.



> 어떤 기능을 설계하는 방법은 한 가지 이상일 수 있다.
>
> 결국 설계는 **트레이드오프의 산물**이다. 모든 사람들을 만족시키는 설계란 없다.





### 의인화



현실에서는 수동적인 존재라고 하더라도 객체지향의 세계에서는 모든것이 능동적이고 자율적인 존재가 된다.

레베카 워프스브록 (Rebecca Wirfs-Brock) 은 능동적이고 자율적인 존재로 소프트웨어 객체를 설계하는 원칙을 **의인화 (anthropomorphism)** 라고 부른다.





### 객체지향 설계



**설계**란 코드를 작성하는 매 순간 코드를 어떻게 배치할 것인지 결정하는 과정에서 나온다.

코드 작성의 일부이며 코드를 작성하지 않고서는 검증이 불가능하다.



#### 좋은 설계 란 ?

오늘 요구하는 기능을 온전히 수행하면서 내일의 변경을 매끄럽게 수용할 수 있는 설계이다.





### 정리하며



요구사항은 항상 변경된다.

요구사항의 변경은 코드의 변경을 의미한다. 코드 변경시 버그가 발생할 수 있다.

우리는 변경에 유연하게 대응할 수 있는 코드가 필요하다. 변경 가능한 코드는 이해하기 쉬운 코드이다.



> 훌륭한 객체지향 설계는 협력하는 객체 사이의 의존성을 적절하게 관리하는 설계이다.
>
> 설계는 **트레이드오프의 산물** 이다 라는 말을 기억하라


# 2장 객체지향 프로그래밍



## 영화 예매 시스템



영화와 상영영화가 있으며 사람들은 상영영화를 예매 한다는 것에 주의

특정 조건을 만족하는 사람은 요금 할인을 받을 수 있는데 이를 결정하는 **할인 조건** 과 **할인 정책** 이 있다.



할인 조건

- 순서 조건과 기간 조건 두 가지 종류가 있다.
- 순서조건은 상영 순번을 이용해 할인 여부를 결정한다.
  - 예를 들어 매일 10번째로 상영되는 영화에 할인 적용
- 기간조건은 상영 시작 시간을 이용해 할인 여부를 결정한다.
  - 예를 들어서 매주 월요일 오전 10시 시작해서 오후 1시에 종료하는 영화에 할인 적용



할인 정책

- 금액 할인 정책과 비율 할인 정책 두 가지 종류가 있다.
- 금액 할인 정책은 예매 요금에서 일정 금액을 할인해 주는 방식이다.
- 비율 할인 정책은 정가에서 일정 비율의 요금을 할인 해주는 방식이다.



| 영화                | 할인 정책              | 할인 조건                                |
| ------------------- | ---------------------- | :--------------------------------------- |
| 아바타 (10,000원)   | 금액 할인 정책 (800원) | 순번 조건 (조조)                         |
|                     |                        | 순번 조건 (10회)                         |
|                     |                        | 기간 조건 (월요일 10시 ~ 12시 사이 시작) |
|                     |                        | 기간 조건 (목요일 18시 ~ 21시 사이 시작) |
| 타이타닉 (11,000원) | 비율 할인 정책 (10%)   | 기간 조건 (화요일 14시 ~ 17시 사이 시작) |
|                     |                        | 순번 조건 (2회)                          |
|                     |                        | 기간 조건 (목요일 10시 ~ 14시 사이 시작) |
| 스타워즈 (10,000원) | 없음                   | 없음                                     |



어떤 사용자가 아바타 (10,000원) 를 예메 한다고 했을 때 의 예매 정보

| 제목      | 아바타                                |
| --------- | ------------------------------------- |
| 상영 정보 | 2019년 12월 26일 (목) 7회 18시 ~ 20시 |
| 인원      | 2명                                   |
| 정가      | 20,000원                              |
| 결재 금액 | 18,400원                              |

> 할인 조건 중 기간 조건인 목요일 18시 ~ 21시 시작 조건을 만족하므로 할인 정책 (800원)이 적용 된다.



## 협력, 객체, 클래스



진정한 객체지향 패러다임으로의 전환은 클래스가 아닌 **객체에 초점** 을 맞춰야 한다.



어떤 클래스가 필요한지 고민하기 전에 어떤 객체들이 필요한지 고민하라.

- 객체들이 어떤 상태와 행동을 가지는지를 먼저 결정해야 한다.

- **객체를 중심에 두는 접근 방법** 은 설계를 단순하고 깔끔하게 만든다.



객체를 독립적인 존재가 아니라 기능을 구현하기 위해 협력하는 공동체의 일원으로 보라.

- 객체는 다른 객체에게 도움을 주거나 의존하며 살아가는 협력적인 존재이다.
- 협력하는 공동체의 일원으로 바라보는 것은 설계를 유연하고 확장 가능하게 만든다.



## 도메인의 구조를 따르는 프로그램 구조



**도메인 (domain) ** 은 문제를 해결하기 위해 사용자가 프로그램을 사용하는 분야를 말한다.



`영화 도메인 구조`

![스크린샷 2020-06-29 오전 7.34.52](/Users/kakaocommerce/Desktop/스크린샷 2020-06-29 오전 7.34.52.png)



### 클래스 구현



클래스를 구현하거나 클래스를 사용할 때 가장 중요한 것은 **클래스의 경계를 구분** 짓는 것이다.

훌륭한 클래스를 설계하기 위한 핵심은 어떤 부분을 감추고 어떤 부분을 외부에 노출 시킬지 결정하는 것이다.

내부와 외부를 구분해야 하는 이유는 **경계의 명확성이 객체의 자율성을 보장** 하기 때문이다.



### 자율적인 객체



객체는 **상태 (state) ** 와 **행동 (behavior)** 을 함께 가지며 스스로 판단하고 행동하는 **자율적인 존재** 이다.

캡슐화와 접근 제어는 객체를 두 부분으로 나눈다.

1. 외부에서 접근 가능한 부분을 퍼블릭 인터페이스 (public interface)
2. 내부에서만 접근 가능한 부분을 구현 (implementation)

> 인터페이스와 구현의 분리 (separation of interface and implementation) 원칙은 훌륭한 객체지향 프로그램을 만들기 위해 따라야 하는 핵심 원칙



### 프로그래머의 자유



프로그래머의 역할은 **클래스 작성자** 와 **클라이언트 프로그래머** 로 구분 할 수 있다.



클라이언트 프로그래머는 애플리케이션을 빠르고 안정적으로 구축 해야하는 것이 목표

클래스 작성자는 외부 인터페이스만 공개하고 내부 구현을 숨기는데 이를 **구현 은닉 (implementation hiding)** 이라고 부른다.

> 객체의 외부와 내부를 구분하면 클래스 작성자가 자유롭게 구현을 변경할 수 있는 폭이 넓어진다.
>
> 설계가 필요한 이유는 변경을 관리하기 위해서라는 것을 기억하라.



`상영 클래스`

````java
class Screening {
  private Movie movie;
  private int sequence;
  private LocalDateTime whenScreened;
  
  public Screening(Movie movie, int sequence, LocalDateTime whenScreened) {
    this.movie = movie;
    this.sequence = sequence;
    this.whenScreened = whenScreened;
  }
  
  public Reservation(Customer customer, int audienceCount) {
    return new Reservation(customer, this, calculateFee(audienceCount), audienceCount);
  }
  
  public LocalDateTime getStartTime() {
    return this.whenScreened;
  }
  
  public boolean isSequence(int sequence) {
    return this.sequence == sequence;
  }
  
  public Money getMovieFee() {
    return this.movie.getFee();
  }
  
  private Money calcuateFee(int audienceCount) {
  	return movie.calcuateMovieFee(this).times(audienceCount);
  }
}
````



`금액 클래스`

금액 클래스를 정의함으로 써 금액과 관련된 로직과 의미를 확실하게 전달할 수 있다.

````java
class Money {
  public static final Money ZERO = Money.wons(0);
  
  private final BigDecimal amount;
  
  public static Money wons(long amount) {
    return new Money(BigDecimal.valueOf(amount));
  }
  
  public static Money wons(double amount) {
    return new Money(BigDecimal.valueOf(amount));
  }
  
  Money(BigDecimal amount) {
    this.amount = amount;
  }
  
  public Money plus(Money amount) {
    return new Money(this.amount.add(amount.amount));
  }
  
  public Money minus(Money amount) {
    return new Money(this.amount.substract(amount.amount));
  }
  
  public Money times(double percent) {
    return new Money(this.amount.multiply(BigDecimal.valueOf(percent)));
  }
  
  public boolean isLessThan(Money other) {
    return amount.compareTo(other.amount) < 0;
  }
  
  public boolean isGreaterThanOrEqual(Money other) {
    return amount.compareTo(other.amount) >= 0;
  }
}
````



`예약 클래스`

````java
class Reservation {
  private Customer customer;
  private Screening screening;
  private Money fee;
  private int audienceCount;
  
  public Reservation(Customer customer, Screening screening, Money fee, int audienceCount) {
    this.customer = customer;
    this.screening = screening;
    this.fee = fee;
    this.audienceCount = audienceCount;
  }
}
````

> 시스템의 어떤 기능을 구현하기 위해 객체들 간에 상호작용을 협력 (Collaboration) 이라고 한다.



### 협력에 관한 짧은 이야기



객체는 **메시지를 전송/수신**  함으로써 다른객체와 상호작용할 수 있으며 메시지를 수신한 객체가 자율적으로 처리할 방법을 결정하는데 이를 **메서드** 라고 부른다.



메시지와 메서드를 구분하는 것은 매우 중요하며, 메시지와 메서드의 구분에서부터 **다형성** 의 개념이 출발한다.



### 컴파일 시간 의존성과 실행 시간 의존성



**클래스 사이의 의존성** 과 **객체 사이의 의존성** 은 서로 다를 수 있다.

코드의 의존성과 실행 시점의 의존성이 다르면 다를수록 이해하기 어려워지지만 더 유연해지고 확장 가능해 진다.

> 항상 유연성과 가독성 사이에서 고민해야 한다.
>
> 무조건 유연한 설계, 무조건 읽기 쉬운코드도 정답이 아니다.



### 차이에 의한 프로그래밍



상속은 객체지향에서 코드를 재사용하기 위해 가장 널리 사용되는 방법이다.

부모 클래스와 다른 부분만을 추가해서 새로운 클래스를 쉽고 빠르게 만드는 방법을 **차이에 의한 프로그래밍** 이라고 한다.



### 상속 과 인터페이스



인터페이스는 객체가 이해할 수 있는 메시지의 목록을 정의한다.

상속을 통해 자식 클래스는 부모 클래스의 인터페이스를 포함하게 된다.



### 다형성



메시지와 메서드는 다른 개념이라는 것을 기억하라.

협력하는 객체가 동일한 메시지를 던지지만, 실제 실행될 메서드를 결정하는 것은 객체의 클래스가 무엇이냐에 따라 달라지는데 이를 **다형성**  이라고 한다.



메시지와 메서드를 실행 시점에 바인딩 하는것을 **지연 바인딩** 또는 **동적 바인딩** 이라고 하고, 컴파일 시점에 바인딩 하는것을 **초기 바인딩 ** 또는 **정적 바인딩** 이라고 한다.



#### 구현 상속과 인터페이스 상속



구현 상속을 **서브 클래싱** 이라 부르고, 인터페이스 상속을 **서브 타이핑** 이라고 한다.

> 이 둘은 목적이 다르며 상속은 인터페이스 상속을 위해 사용해야 한다.



### 추상화와 유연성



추상화는 세부사항에 억눌리지 않고 도메인의 중요한 개념을 설명할 수 있다.

추상화를 이용해 기본적인 애플리케이션의 협력 흐름 기술이 가능하다.

재사용 가능한 설계의 기본인 **디자인 패턴** 이나 **프레임 워크** 모두 추상화를 이용하고 있다.



### 코드 재사용과 상속



상속은 코드를 재사용하기 위해 널리 사용되는 기법이지만 두가지 관점에서 설계에 안좋은 영향을 미친다.

1. 캡슐화를 위반한다.
2. 설계를 유연하지 못하게 만든다.



### 합성



합성은 인터페이스에 정의된 메시지만을 통해 코드를 재사용하는 방법이며, 상속이 가지는 두 가지 문제점을 모두 해결한다.

> 대부분의 설계에서는 상속과 합성을 함께 사용해야 한다.

# 3장 역할, 책임, 협력


객체지향 패러다임의 관점에서 핵심은 **역할 (role)** , **책임 (responsibililty)** , **협력 (collaboration)** 이다.

객체지향의 본질은 협력하는 **객체들의 공동체**를 창조 하는것 이다.

## 협력

영화 예매 시스템을 되돌아보면, 다양한 객체들이 영화 예매라는 기능을 구현하기 위해 메시지를 주고 받으며 상호작용하고 있다.

이런 상호작용을 **협력** 이라고  하며, 협력에 참여하기 위해 수행하는 로직을 **책임** 이라고 부른다.

협력 안에서 수행하는 책임들이 모여 객체가 수행하는 **역할**을 구성한다.

두 객체 간의 협력은 객체가 다른 객체에게 도움을 요청할 때 시작되는데, 이들의 유일한 커뮤니케이션 수단은 **메시지 전송**이다.

- 객체는 다른 객체의 세부 구현에 직접 접근 할 수 없기 때문에 오직 메시지 만을 통해 의사소통 할 수 있다.

어떤 객체도 섬이 아니다.[Beck89]. 객체가 필요하다면 그 이유는 단 하나여야 한다.

객체가 참여하는 협력이 객체를 구성하는 행동과 상태를 모두 결정한다.

즉 협력은, 객체를 설계하는데 필요한 일종의 **문맥 (Context)** 을 제공한다.

## 책임

협력에 참여하기 위해 객체가 수행하는 행동을 **책임** 이라고 한다.

- 객체의 책임은 크게 두 가지 범주로 나누어 세분화 하고 있다.
  1. 하는 것
     - 객체를 생성하거나 계산을 수행하는 등의 스스로 하는것
     - 다른 객체의 행동을 시작시키는 것
     - 다른 객체의 활동을 제어하고 조절하는 것

  2. 아는 것
     - 사적인 정보에 관해 아는 것
     - 관련된 객체에 관해 아는 것
     - 자신이 유도하거나 계산할 수 있는 것에 관해 아는 것

- 일반적으로 책임과 메시지의 크기는 다르다.

책임은 객체지향 설계의 핵심이다. 객체지향 개발에서 가장 중요한 능력은 책임을 능숙하게 소프트웨어 객체에게 할당하는 것이다.

책임을 찾고 책임을 수행할 적절한 객체를 찾아 책임을 할당하는 설계 방식을 **책임 주도 설계 (Responsibility-Driven Design, RDD) 라고 부른다.**

객체에게 책임을 할당하는데 필요한 메시지를 식별하고, 처리할 객체를 나중에 선택하는 것이 중요하다.

다시 말하면, 객체가 메시지를 선택하는 것이 아니라 **메시지가 객체를 선택**하게 해야 한다.

- 메시지가 객체를 선택하게 해야 하는 이유 ?
  1. 객체는 **최소한의 인터페이스**를 가지게 된다.
  2. 객체는 충분히 **추상적인 인터페이스**를 가지게 된다.

객체지향 패러다임에 갓 입문한 사람들이 가장 쉽게 빠지는 실수는 객체의 **상태** 에 초점을 맞추는 것이다.

객체의 세부 구현이 외부 인터페이스에 노출되므로 **캡슐화** 를 저해한다.

이런 설계 방식을  **데이터 주도 설계 (Data-Driven Design)** 라고 한다.

중요한 것은 객체의 상태가 아닌 **행동** 임을 기억하라.

## 역할

역할이 중요한 이유는 역할을 통해 **유연하고 재사용 가능한 협력**을 얻을 수 있기 때문이다.

영화 예매 도메인에서 **금액 할인 정책** 과 **비율 할인 정책** 이 존재할 때, 협력 별로 각각 구현해야할까 ?

이들은 **할인 정책** 이라는 역할로 묶을 수 있다.

여기서 역할은 두 종류의 구체적인 객체를 포괄하는 **추상화** 이다.

역할을 구현하는 가장 일반적인 방법은 **추상 클래스** 와 **인터페이스** 이다.

협력의 관점에서 구체 클래스 들이 따라야 하는 책임의 집합을 서술한 것이다.

역할은 다양한 종류의 객체를 수용할 수 있는 일종의 **슬롯** 이자, 구체적인 객체 들의 타입을 캡슐화 하는 **추상화** 이다.

역할은 객체가 참여 할 수 있는 슬롯이다.

하지만 한 종류의 객체만 협력에 참여하는 경우 역할이라는 개념을 생략하고 직접 객체를 이용해 설계하는 것이 더 좋다.

협력에 참여하는 후보가 오직 한 종류의 객체 라면 후보는 역할이 아닌 객체가 된다.

- 협력 → 역할 → 객체 → 클래스

> 역할이 중요한 이유는 동일한 협력을 수행하는 객체들을 추상화 할 수 있기 때문이다.


# 4장 설계 품질과 트레이드 오프

객체지향 설계의 핵심은 **역할** , **책임** , **협력** 이며 **책임** 이 객체지향 애플리케이션 전체의 품질을 결정한다.

훌륭한 설계는 적절한 비용 내에서 쉽게 변경할 수 있는 구조를 만드는 것이다.

객체지향 설계의 시작은, 객체의 **상태** 가 아닌 객체의 **행동** 에 초점을 맞추는 것

## 데이터 중심 설계

**데이터 중심 설계** 란, 객체 내부에 저장되는 데이터를 기반으로 시스템을 분할하는 방법이다.

```java
// 상품 클래스
class Product {
	// == 기본 속성들 == //
	private Long productId;
	private String name;
	private String description;
	private int price;
	...
	
	// == 할인 관련 == //
	private DiscountType discountType;
	private Bigdecimal percent;
	...

	getter, setter...
} 

// 할인 타입
enum DiscountType {
	TALK_DEAL,
	NONE,
	...
}

// 기타 등등..

// 주문 서비스
class OrderService {

	void order(Long productId, ...) {
		Product product =	find(productId);
		DiscountType = discountType = product.getDiscountType();
		
		if (dicountType == DiscountType.TALK_DEAL) {
			// getter, setter 호출..
			...
		} else {
			// getter, setter 호출..
			...
		}
	}
}
```

프로젝트의 많은 부분이 위와 같은 방식으로 되어 있다.

### 문제점

- 현재 설계는 **결합도** 가 높고, **응집도** 가 낮은 설계
  - Product와 OrderService는 **강결합** 되어 있다.
    - 할인 관련 정책이 변경 된다면 ?..
    - 퍼센트 할인이 아닌, 금액 할인 등..

- 결합도
  - 의존성의 정도
  - 다른 모듈의 세부 구현을 얼마나 알고 있나 ?
- 응집도
  - 모듈에 포함된 내부 요소들의 연관된 정도

**결합도** 가 높고, **응집도** 가 낮은 설계는 변경에 취약하다.

### 캡슐화 위반

접근 제어자 를 private 으로 설정하고, getter, setter 를 통해 접근한다고 해서 캡슐화 원칙을 지키는 것은 아니다. 

getXXX(), setXXX() 와 같이 내부의 property 를 외부에 노골적으로 노출하고 있는것 과 동일하다.

이처럼 접근자와 수정자에 과도하게 의존하는 설계 방식을 **추측에 의한 설계 전략 (design-by-guessing strategy)** 라고 한다.

### 높은 결합도

Product의 할인 관련 구현이 변경되면, 이를 사용하는 OrderService 도 함께 변경되어야 한다.

### 낮은 응집도

서로 다른 이유로 변경되는 코드가 하나의 모듈 내에 존재할 때, 응집도 가 낮다고 표현한다.

> 현재의 설계는 할인 관련 정책을 수정하기 위해, Product가 수정 되어야 하며, Product가 수정되면 OrderService 도 영향을 받는다.

### 단일 책임 원칙 (Single Responsibility Principle, SRP)

[객체 지향 프로그래밍](https://ko.wikipedia.org/wiki/%EA%B0%9D%EC%B2%B4_%EC%A7%80%ED%96%A5_%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D)에서 **단일 책임 원칙**(single responsibility principle)이란 모든 클래스는 하나의 책임만 가지며, 클래스는 그 책임을 완전히 [캡슐화](https://ko.wikipedia.org/wiki/%EC%BA%A1%EC%8A%90%ED%99%94) 해야 함을 일컫는다. 클래스가 제공하는 모든 기능은 이 책임과 주의 깊게 부합해야 한다.

## 정리

- 데이터 중심 설계가 변경에 취약한 이유
  - 객체의 행동보다 상태에 초점을 맞춘다.
    - 설계를 시작할 때 객체가 가지는 **데이터** 를 먼저 정의한다.
    - **절차적 프로그래밍** 을 따르고 있다.

  - 객체를 고립시킨 채 오퍼레이션을 정의한다.
    - 초점이 객체의 외부가 아닌, 내부이다.
    
    
# 5장 책임 할당하기

책임에 초점을 맞춰 설계할 때 가장 큰 어려움은 **어떤 객체에게 어떤 책임을 할당할 것인가**  이다.

**GRASP 패턴** 은 책임 할당의 어려움을 해결하기 위한 답을 제시해 준다.

## 책임 주도 설계

- 책임 주도 설계로 전환하기 위한 두가지 원칙
  - 데이터 보다 행동을 먼저 결정하라
  - 협력이라는 문맥 내에서 책임을 결정하라

### 데이터보다 행동을 먼저 결정하라

객체의 행동이 아닌 데이터에 초점을 맞추면 객체의 **캡슐화** 가 약화된다.

그에 따라 **낮은 응집도와 높은 결합도** 를 가진 객체를 만들게 된다. 이는 변경에 취약한 설계이다.

객체지향 설계에서 가장 중요한 것은 적절한 객체에게 적절한 책임을 할당하는 능력

### 협력이라는 문맥 내에서 책임을 결정하라

객체 간의 협력은 **메시지** 를 통해 이루어진다.

메시지를 전송하는 클라이언트의 의도에 적합한 **책임** 을 할당 해야 한다.

객체를 결정한 뒤 메시지를 선택 하는 것이 아닌, 메시지를 결정한 후에 객체를 선택 해야 한다.

## GRASP 패턴

GRASP (General Responsibility Assignment Software Pattern) 은 객체에게 책임을 할당할 때 지침으로 삼을 수 있는 원칙들의 집합을 패턴 형식으로 정리한 것이다.

### Information Expert Pattern

책임을 수행할 정보를 알고 있는 객체에게 책임을 할당 하라.

정보와 행동을 최대한 가까운 곳에 위치시켜 캡슐화를 유지하라.

여기서 말하는 **정보** 는 데이터 와는 다르다는 점에 주의하라. 해당 정보를 제공할 객체를 알고 있거나 필요한 정보를 계산하여 제공할 수 있다.

### Low Coupling Pattern

설계의 전체적인 **결합도** 가 낮게 유지되도록 책임을 할당하라.

### High Cohesion Pattern

높은 **응집도** 를 유지할 수 있게 책임을 할당하라.

### Creator Pattern

객체와 연결되거나 관련될 필요가 있는 객체에게 해당 객체를 생성할 책임을 맡겨라.

해당 객체에 대해 잘 알거나 객체를 사용 해야 하는 객체는 어떤 방식으로든 결합된다.

### Polymorphism Pattern

타입을 명시적으로 정의하고 각 타입에 다형적으로 행동하는 **책임** 을 할당하라.

### Protected Variations Pattern

변화가 예상되는 불안정한 지점들을 식별하고 그 주위에 안정된 인터페이스를 형성하도록 책임을 할당하라.
