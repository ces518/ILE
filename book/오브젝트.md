# 오브젝트

오브젝트 스터디 대비 정리




## 서론



### 프로그래밍 패러다임이 중요한 이유 ?



개발자 공동체가 동일한 프로그래밍 스탈와 모델을 공유할수 있게 함으로써 불필요한 부분에 대한 의견 충돌을 방지한다.

동일한 규칙와 방법을 공유하는 개발자로 성장할 수 있도록 준비시킬 수있다.



프로그래밍 패러다임은 두 가지이상 패러다임이 공존할 수 있다.

하나의 언어내에서 공존함으로써 서로의 단점을 보완한다.

대표적인 예로 C++ (절차지향 + 객체지향), Scala(함수형 + 객체지향) 가 있다.

이 처럼 하나 이상의 패러다임을 수용한 언어를 다중패러다임 언어 라고 한다.



> 프로그래밍 패러다임은 혁명적 (revolutionary) 인 것이 아닌, 발전적 (evolutionary) 인 것이다.



'은총알은 없다' 라는 프레디 브룩스의 말을 기억하라. 객체지향이 적합하지 않다면 언제라도 다른 패러다임을 적용할 수 있는 시야를 기르고 지식을 갈고 닦아야 한다.





## 1장 객체, 설계





### 티켓 판매 애플리케이션



티켓 판매 애플리케이션 구현에 앞서 요구사항을 정의해 보자.



연극이나, 음악회를 공연할 수 있는 소극장을 운영중이다.

소극장을 홍보하기 위해 작은 이벤트를 기획하였다.

이벤트에 당첨된 관람객과, 일반 관람객은 각자 다른 방식으로 입장 시켜야한다.

- 이벤트 당첨 관람객은 초대장을 **티켓으로 교환** 한 뒤 입장을 해야한다.
- 당첨되지 못한 관람객은 **티켓을 구매** 한 뒤 입장을 해야한다.



`초대장 클래스`

````java
class Invitaion {
  private LocalDateTime when;
}
````



`티켓 클래스`

````java
class Ticket {
  private Long fee;
}
````



`소지품 클래스`

```java
class Bag {
  private Long amount;
  private Invitation inviation;
  private Ticket ticket;
  
  public Bag(long amount) {
    this(nul, amount);
  }
  
  public Bag(Invitation inviation, long amount) {
    this.inviation = invaition;
    this.amount = amount;
  }
  
  // ==  비즈니스 메소드 ==//
  public boolean hasInvitation() {
    return invitation != null;
  }
  
  public boolean hasTicket() {
    return ticket != null;
  }
  
  public void setTicket(Ticket ticket) {
    this.ticket = ticket;
  }
  
  public void minusAmount(Long amount) {
    this.amount -= amount;
  }
  
  public void plusAmount(Long amount) {
  	this.amount += amount; 
  }
}
```



`관람객 클래스`

````java
class Audience {
  private Bag bag;
  
  public Audience(Bag bag) {
    this.bag = bag;
  }
  
  public Bag getBag() {
    return bag;
  }
}
````



> 관람객은 소지품에 초대권, 티켓, 현금을 가질 수 있다.
>
> 관람객이 입장하기 위해서는 초대권 혹은 현금을 가지고 있어야한다.
>
> 따라서 소지품 클래스 생성시 초대권 혹은 현금을 가질수 있도록 생성자를 이용하여 제약조건을 추가하였다.



`매표소 클래스`

````java
class TicketOffice {
  private Long amount;
  private List<Ticket> tickets = new ArrayList<>();
  
  public TicketOffice(Long amount, Ticket ... tickets) {
    this.amount = amount;
    this.tickets.addAll(Arrays.asList(tickets));
  }
  
  public Ticket getTicket() {
    return tickets.remove(0);
  }
  
  public void minusAmount(Long amount) {
    this amount -= amount;
  }
  
  public void plusAmount(Long amount) {
    this.amount += amount;
  }
}
````



`판매원 클래스`

````java
class TicketSeller {
  private TicketOffice TicketOffice;
  
  public TicketSeller(TicketOffice TicketOffice) {
    this.TicketOffice = TicketOffice;
  }
  
  public TicketOffice getTicketOffice() {
    return ticketOffice;
  }
}
````



`소극장 클래스`

````java
class Theater {
  private TicketSeller ticketSeller;
  
  public Theater(TicketSeller ticketSeller) {
    this.ticketSeller = ticketSeller;
  }
  
  public void enter(Audience audience) {
    if (audience.getBag().hasInvitation()) {
      Ticket ticket = ticketSeller.getTicketOffice().getTicket();
      audience.getBag().setTicket(ticket);
    } else {
			Ticket ticket = ticketSeller.getTicketOffice().getTicket();
      audience.getBag().minusAmount(ticket.getFee());
      ticketSeller.getTicketOffice().plusAmount(ticket.getFee());
      audience.getBag().setTicket(ticket);
    }
  }
}
````





### 소프트웨어 모듈의 3가지 목적

- 실행 중에 제대로 동작해야 한다.
- 변경을 위해 존재하는것. 변경하기 어려운 모듈은 제대로 동작 하더라도 개선해야 한다.
- 코드를 읽는 사람과 의사소통하는것. 특별한 훈련 없이도 개발자가 쉽게 읽고 이해할 수 있어야 한다.





### 문제점



관람객과 판매원이 소극장의 통제를 받는 **수동적인 구조** 이다.



이해 가능한 코드란 우리의 예상에서 크게 벗어나지 않는 코드이다.

위의 구조에서는 소극장이 관람객의 가방을 뒤져 초대권을 확인 한뒤, 판매원의 티켓을 가져와 지급한다.

또한 이 코드는 여러 가지 세부적인 내용들을 한꺼번에 기억하고 있어야 한다.

관람객이 가방을 가지고 있고, 가방에는 현금과 티켓이 들어 있으며, 판매원이 오피스에서 티켓을 판매하고... 이런 사실들을 모두 기억하고 있어야 한다.



> 하나의 클래스나 메서드에서 너무 많은 일을 하기 때문에 문제가 된다.
>
> 가장 심각한 문제는 관람객이나, 판매원이 변경될 경우, 소극장의 코드도 영향을 받는다는 점이다.



객체 사이의 의존성 (dependency) 와 관련된 문제이다.

의존성은 변경에 대한 영향을 암시한다. 그렇다고 객체 사이의 의존성을 완전히 없애는 것은 답이 아니다.

**최소한의 의존성만 유지** 하고 불필요한 의존성을 제거하는 것이다.



객체 간의 의존성이 과한경우 **결합도 (coupling)** 가 높다고 말한다.





### 설계 개선하기



코드를 이해하기 어려운 이유는 소극장이 **관람객의 가방과 매표소에 직접 접근** 하기 때문이다.

소극장이 관람객과 판매원에 대해 세세한 부분까지 알지 못하도록 변경하면 된다.

관람객과 판매원을 **자율적인 존재** 로 만들자.



`소극장 클래스`

````java
class Theater {
  private TicketSeller ticketSeller;
  
  public Theater(TicketSeller ticketSeller) {
    this.ticketSeller = ticketSeller;
  }
  
  public void enter(Audience audience) {
    ticketOffice.sellTo(audience);
  }
}
````



`판매원 클래스`

````java
class TicketSeller {
  private TicketOffice ticketOffice;
  
  public TicketSeller(TicketOffice ticketOffice) {
    this.TicketOffice = ticketOffice;
  }
  
  public void sellTo(Audience audience) {
  	ticketOffice.plusAmount(audience.buy(ticketOffice.getTicket()));
  }
  
  // == 제거 == //
  public TicketOffice getTicketOffice() {
    return ticketOffice;
  }
  // == == //
}
````



`관람객 클래스`

````java
class Audience {
  private Bag bag;
  
  public Audience(Bag bag) {
    this.bag = bag;
  }
  
  public Long buy(Ticket ticket) {
    if (bag.hasInvitation()) {
      bag.setTicket(ticket);
      return 0L;
    } else {
      bag.minusAmount(ticket.getFee());
      bag.setTicket(ticket);
      return ticket.getFee();
    }
  }
  
  // == 제거 == //
  public Bag getBag() {
    return bag;
  }
  // == == //
}
````



소극장은 더이상 관람객과, 판매원에게 개입하지 않는다.

관람객과 판매원 역시 서로간의 대화를 통한 **자율적인 객체**가 되었다.



> 중요한 점은 관람객이나 판매원의 내부 구현이 변경되더라도 서로에게 영향을 주지 않는다.
>
> 수정된 코드는 변경 용이성 측면에서도 확실히 개선 되었다.





### 캡슐화와 응집도



핵심은 객체 내부의 상태를 캡슐화하고 **객체 간에 오직 메시지 (대화) 를 통해서만 상호작용 하도록 만드는 것** 이다.

밀접하게 연관된 작업만을 수행하고 연관성 없는 작업은 다른 객체에게 위힘하는 것을 가리켜 **응집도 (cohesion)** 가 높다고 말한다.





### 절치지향과 객체지향



소극장의 enter() 메소드는 **프로세스 (process)** 이며, 관람객, 판매원, 티켓 등은 **데이터 (Data)** 이다.

개선전 소극장의 enter() 메소드 처럼 프로세스와 데이터를 별도의 모듈에 위치시키는 방식을 **절차적 프로그래밍(Procedural Programming)**

데이터와 프로세스가 동일한 모듈 내부에 존재하는 것을 **객체지향 프로그래밍 (Object-Oridented Programming)** 이라고 한다.



> 절치적 프로그래밍은 일반적으로 우리의 예상을 벗어나기 때문에 쉽게 읽지 못하는 코드일 확률이 높으며, 변경에 취약하다.
>
> 반면, 객체지향 프로그래밍은 객체를 **자율적인 존재**로 만들기 때문에 보다 이해하기 쉽고, 변경에 유연하다.





### 책임의 이동



절차적 프로그래밍과 객체지향 프로그래밍의 근본적인 차이를 만드는것은 **책임의 이동 (shift of responsesibility)** 이다.

절차적 프로그래밍은 소극장 (Threater) 에게 **책임이 집중**되어 있고, 객체지향 프로그래밍은 각 객체에게 **책임이 적절히 분배**되어 있다.

객체는 다른 객체와의 협력 안에서 특정한 역할을 수행하는 데 필요한 적절한 책임을 수행해야 한다.



> 설계를 어렵게 만드는 것은 **의존성**이다.
>
> 좋은 설계는 불필요한 의존성을 제거함으로 써 객체간의 **결합도**를 낮춰야한다.
>
> 이전 코드에서 선택한 방법은 각 객체 내부로 감춰 **캡슐화** 하는 방법을 사용했다.
>
> 캡슐화는 객체의 **자율성**을 높이고 **응집도** 높은 객체를 만드는 방법이다.





### 추가 개선하기



현재 설계는 이전보다 분명히 좋아졌지만, 아직 개선의 여지가 있다.



`소지품 클래스`

````java
class Bag {
  private Long amount;
  private Ticket ticket;
  private Invitation inviation;
  
  public Long hold(Ticket ticket) {
    if (hasInvitation()) {
      setTicket(ticket);
      return 0L;
    } else {
      setTicket(ticket);
      minusAmount(ticket.getFee());
      return ticket.getFee();
    }
  }
  
  private void setTicket(Ticket ticket) {
    this.ticket = ticket;
  }
  
  private boolean hasInvitation() {
    return invitation != null;
  }
  
  private void minusAmount(Long amount) {
    this.amount -= amount;
  }
}
````



`관람객 클래스`

````java
class Audience {
  public Long buy(Ticket ticket) {
    return bag.hold(ticket);
  }
}
````



`매표소 클래스`

````java
class TicketOffice {
  public void setTicketTo(Audience audience) {
    plusAmount(audience.buy(getTicket()));
  }
  
  private Ticket getTicket() {
    return tickets.remove(0);
  }
  
  private void plusAmount(Long amount) {
    this.amount += amount;
  }
}
````



`판매원 클래스`

````java
class TicketSeller {
  public void sellTo(Audience audience) {
    ticketOffice.sellTicketTo(audience);
  }
}
````



추가 개선이후, 각 객체들이 좀 더 자율적인 존재가 되었지만, 만족스러운 상황은 아니다.

그 이유는 변경 전에는 존재하지 않았던 **새로운 의존성 (매표소와 관람객)** 이 생겨났기 때문이다.



> 어떤 기능을 설계하는 방법은 한 가지 이상일 수 있다.
>
> 결국 설계는 **트레이드오프의 산물**이다. 모든 사람들을 만족시키는 설계란 없다.





### 의인화



현실에서는 수동적인 존재라고 하더라도 객체지향의 세계에서는 모든것이 능동적이고 자율적인 존재가 된다.

레베카 워프스브록 (Rebecca Wirfs-Brock) 은 능동적이고 자율적인 존재로 소프트웨어 객체를 설계하는 원칙을 **의인화 (anthropomorphism)** 라고 부른다.





### 객체지향 설계



**설계**란 코드를 작성하는 매 순간 코드를 어떻게 배치할 것인지 결정하는 과정에서 나온다.

코드 작성의 일부이며 코드를 작성하지 않고서는 검증이 불가능하다.



#### 좋은 설계 란 ?

오늘 요구하는 기능을 온전히 수행하면서 내일의 변경을 매끄럽게 수용할 수 있는 설계이다.





### 정리하며



요구사항은 항상 변경된다.

요구사항의 변경은 코드의 변경을 의미한다. 코드 변경시 버그가 발생할 수 있다.

우리는 변경에 유연하게 대응할 수 있는 코드가 필요하다. 변경 가능한 코드는 이해하기 쉬운 코드이다.



> 훌륭한 객체지향 설계는 협력하는 객체 사이의 의존성을 적절하게 관리하는 설계이다.
>
> 설계는 **트레이드오프의 산물** 이다 라는 말을 기억하라


# 2장 객체지향 프로그래밍



## 영화 예매 시스템



영화와 상영영화가 있으며 사람들은 상영영화를 예매 한다는 것에 주의

특정 조건을 만족하는 사람은 요금 할인을 받을 수 있는데 이를 결정하는 **할인 조건** 과 **할인 정책** 이 있다.



할인 조건

- 순서 조건과 기간 조건 두 가지 종류가 있다.
- 순서조건은 상영 순번을 이용해 할인 여부를 결정한다.
  - 예를 들어 매일 10번째로 상영되는 영화에 할인 적용
- 기간조건은 상영 시작 시간을 이용해 할인 여부를 결정한다.
  - 예를 들어서 매주 월요일 오전 10시 시작해서 오후 1시에 종료하는 영화에 할인 적용



할인 정책

- 금액 할인 정책과 비율 할인 정책 두 가지 종류가 있다.
- 금액 할인 정책은 예매 요금에서 일정 금액을 할인해 주는 방식이다.
- 비율 할인 정책은 정가에서 일정 비율의 요금을 할인 해주는 방식이다.



| 영화                | 할인 정책              | 할인 조건                                |
| ------------------- | ---------------------- | :--------------------------------------- |
| 아바타 (10,000원)   | 금액 할인 정책 (800원) | 순번 조건 (조조)                         |
|                     |                        | 순번 조건 (10회)                         |
|                     |                        | 기간 조건 (월요일 10시 ~ 12시 사이 시작) |
|                     |                        | 기간 조건 (목요일 18시 ~ 21시 사이 시작) |
| 타이타닉 (11,000원) | 비율 할인 정책 (10%)   | 기간 조건 (화요일 14시 ~ 17시 사이 시작) |
|                     |                        | 순번 조건 (2회)                          |
|                     |                        | 기간 조건 (목요일 10시 ~ 14시 사이 시작) |
| 스타워즈 (10,000원) | 없음                   | 없음                                     |



어떤 사용자가 아바타 (10,000원) 를 예메 한다고 했을 때 의 예매 정보

| 제목      | 아바타                                |
| --------- | ------------------------------------- |
| 상영 정보 | 2019년 12월 26일 (목) 7회 18시 ~ 20시 |
| 인원      | 2명                                   |
| 정가      | 20,000원                              |
| 결재 금액 | 18,400원                              |

> 할인 조건 중 기간 조건인 목요일 18시 ~ 21시 시작 조건을 만족하므로 할인 정책 (800원)이 적용 된다.



## 협력, 객체, 클래스



진정한 객체지향 패러다임으로의 전환은 클래스가 아닌 **객체에 초점** 을 맞춰야 한다.



어떤 클래스가 필요한지 고민하기 전에 어떤 객체들이 필요한지 고민하라.

- 객체들이 어떤 상태와 행동을 가지는지를 먼저 결정해야 한다.

- **객체를 중심에 두는 접근 방법** 은 설계를 단순하고 깔끔하게 만든다.



객체를 독립적인 존재가 아니라 기능을 구현하기 위해 협력하는 공동체의 일원으로 보라.

- 객체는 다른 객체에게 도움을 주거나 의존하며 살아가는 협력적인 존재이다.
- 협력하는 공동체의 일원으로 바라보는 것은 설계를 유연하고 확장 가능하게 만든다.



## 도메인의 구조를 따르는 프로그램 구조



**도메인 (domain) ** 은 문제를 해결하기 위해 사용자가 프로그램을 사용하는 분야를 말한다.



`영화 도메인 구조`

![스크린샷 2020-06-29 오전 7.34.52](/Users/kakaocommerce/Desktop/스크린샷 2020-06-29 오전 7.34.52.png)



### 클래스 구현



클래스를 구현하거나 클래스를 사용할 때 가장 중요한 것은 **클래스의 경계를 구분** 짓는 것이다.

훌륭한 클래스를 설계하기 위한 핵심은 어떤 부분을 감추고 어떤 부분을 외부에 노출 시킬지 결정하는 것이다.

내부와 외부를 구분해야 하는 이유는 **경계의 명확성이 객체의 자율성을 보장** 하기 때문이다.



### 자율적인 객체



객체는 **상태 (state) ** 와 **행동 (behavior)** 을 함께 가지며 스스로 판단하고 행동하는 **자율적인 존재** 이다.

캡슐화와 접근 제어는 객체를 두 부분으로 나눈다.

1. 외부에서 접근 가능한 부분을 퍼블릭 인터페이스 (public interface)
2. 내부에서만 접근 가능한 부분을 구현 (implementation)

> 인터페이스와 구현의 분리 (separation of interface and implementation) 원칙은 훌륭한 객체지향 프로그램을 만들기 위해 따라야 하는 핵심 원칙



### 프로그래머의 자유



프로그래머의 역할은 **클래스 작성자** 와 **클라이언트 프로그래머** 로 구분 할 수 있다.



클라이언트 프로그래머는 애플리케이션을 빠르고 안정적으로 구축 해야하는 것이 목표

클래스 작성자는 외부 인터페이스만 공개하고 내부 구현을 숨기는데 이를 **구현 은닉 (implementation hiding)** 이라고 부른다.

> 객체의 외부와 내부를 구분하면 클래스 작성자가 자유롭게 구현을 변경할 수 있는 폭이 넓어진다.
>
> 설계가 필요한 이유는 변경을 관리하기 위해서라는 것을 기억하라.



`상영 클래스`

````java
class Screening {
  private Movie movie;
  private int sequence;
  private LocalDateTime whenScreened;
  
  public Screening(Movie movie, int sequence, LocalDateTime whenScreened) {
    this.movie = movie;
    this.sequence = sequence;
    this.whenScreened = whenScreened;
  }
  
  public Reservation(Customer customer, int audienceCount) {
    return new Reservation(customer, this, calculateFee(audienceCount), audienceCount);
  }
  
  public LocalDateTime getStartTime() {
    return this.whenScreened;
  }
  
  public boolean isSequence(int sequence) {
    return this.sequence == sequence;
  }
  
  public Money getMovieFee() {
    return this.movie.getFee();
  }
  
  private Money calcuateFee(int audienceCount) {
  	return movie.calcuateMovieFee(this).times(audienceCount);
  }
}
````



`금액 클래스`

금액 클래스를 정의함으로 써 금액과 관련된 로직과 의미를 확실하게 전달할 수 있다.

````java
class Money {
  public static final Money ZERO = Money.wons(0);
  
  private final BigDecimal amount;
  
  public static Money wons(long amount) {
    return new Money(BigDecimal.valueOf(amount));
  }
  
  public static Money wons(double amount) {
    return new Money(BigDecimal.valueOf(amount));
  }
  
  Money(BigDecimal amount) {
    this.amount = amount;
  }
  
  public Money plus(Money amount) {
    return new Money(this.amount.add(amount.amount));
  }
  
  public Money minus(Money amount) {
    return new Money(this.amount.substract(amount.amount));
  }
  
  public Money times(double percent) {
    return new Money(this.amount.multiply(BigDecimal.valueOf(percent)));
  }
  
  public boolean isLessThan(Money other) {
    return amount.compareTo(other.amount) < 0;
  }
  
  public boolean isGreaterThanOrEqual(Money other) {
    return amount.compareTo(other.amount) >= 0;
  }
}
````



`예약 클래스`

````java
class Reservation {
  private Customer customer;
  private Screening screening;
  private Money fee;
  private int audienceCount;
  
  public Reservation(Customer customer, Screening screening, Money fee, int audienceCount) {
    this.customer = customer;
    this.screening = screening;
    this.fee = fee;
    this.audienceCount = audienceCount;
  }
}
````

> 시스템의 어떤 기능을 구현하기 위해 객체들 간에 상호작용을 협력 (Collaboration) 이라고 한다.



### 협력에 관한 짧은 이야기



객체는 **메시지를 전송/수신**  함으로써 다른객체와 상호작용할 수 있으며 메시지를 수신한 객체가 자율적으로 처리할 방법을 결정하는데 이를 **메서드** 라고 부른다.



메시지와 메서드를 구분하는 것은 매우 중요하며, 메시지와 메서드의 구분에서부터 **다형성** 의 개념이 출발한다.



