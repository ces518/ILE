# 대규모 서비스를 지탱하는 기술

## 대규모 데이터 처리의 어려운 점 - 메모리와 디스크

#### 대규모 데이터를 다룰 때 힘든점은, **메모리 내에서 계산할 수 없다.** 는 점
- 메모리에 올리지 않으면, 기본적으로 디스크를 계속해서 읽어가며 처리 해야한다.
- 데이터 건수가 많아질수록 계산량도 늘어남.
- 디스크 I/O는 매우 느리다.

#### 메모리와 디스크의 속도차이
- 메모리와 디스크는 10의 5승 ~ 10의6승 배 이상 빠르다.
    
#### 디스크가 느린 이유 ?
- 디스크는 동축 상에 '원반'이 쌓여 있다. 원반이 회전하고 있으며, 여기서 데이터를 읽어냄.
- 메모리와 달리 디스크는 **물리적인 동작** 을 수반하고 있음.
- 이 원반 뿐 아니라, 데이터를 읽어내는 '헤드' 도 존재한다.
- 헤드가 붙어 데이터를 읽어 내야 한다.
- 헤드의 이동, 원반의 회전단위 => 각각 4밀리초
- 데이터가 여기저기 분산되어 있을수록, 디스크에서 읽어 들이는 속도는 느려진다.
    
#### OS 레벨 에서의 연구
- OS에서 이를 어느정도 커버하는 작용을 한다.
- OS는 연속된 데이터를 같은 위치에 쌓는데 이는 4KB 단위로 수행한다.
- 비슷한 데이터를 비슷한 위치에 두어 1번 회전으로 읽어들이는 데이터 수를 증가 시켜 이를 완화한다.

#### 전송 속도, 버스의 속도 차이
- 탐색 속도 측면에서 메모리가 디스크에 비해 빠르지만, 이것만의 차이가 아니다.
- 메모리와 디스크 모두 CPU 와 버스로 연결되어 있는데, 이 버스의 전송 속도도 차이가 남.
- 메모리와 CPU는 7.5GB/s, 디스크는 58MB/s 
- SSD로 인해 탐색 속도는 빠르지만, 전송 속도에서 차이가 난다.

#### Linux 단일 호스트의 부하
- 단일 서버의 성능을 충분히 끌어낼 수 있는것을 시작으로 복수 서버의 부하분산이 의미를 가진다.
- **추측하지 말고, 계측하라.**
- 병목 규명작업의 기본 흐름
    - Load Average 확인
    - CPU, I/O 병목 원인 조사

`Load Average 확인`
- 부하 규명의 시작이 되는 지표
- top, uptime 등 명령으로 확인 한다.
- 시스템 전체의 부하상황을 나타내는 지표
- Load Average 는 낮은데, 시스템 전송량이 낮은 경우도 있다.
- 소프트웨어 설정, 오류, 네트워크, 원격 호스트 등을 살펴보라.

`CPU I/O 병목 원인 조사`
- sar, vmstat로 CPU 사용률 과 I/O 대기율 추이 확인
- CPU에 부하가 걸리는 상황 두가지
    - 디스크나 메모리 용량 등 그 밖의 부분에서는 병목이 되지않는 이상적인 상태
    - 프로그램이 폭주하여 CPU에 필요 이상의 부하가 걸리는 경우
- I/O 부하가 높은 경우
    - 프로그램에서 입출력이 많음
    - 스왑이 발생해서 디스크 액세스가 발생하고 있는 상황

> 스왑이 발생하지 않고, 디스크 I/O가 많은 경우 캐시에 필요한 메모리가 부족한 경우도 있다.

- OS 튜닝이란 부하의 원인을 알고 이것을 제거하는 것이다.
- 튜닝의 본질은 하드웨어/소프트웨어가 가지고 있는 본래 성능을 충분히 내도록 문제가 되는 부분을 제거하는것

## 규모조정의 요소

#### 규모조정, 확장성
- 웹 서비스에서는 고가의 하드웨어를 사서 성능을 올리는 **스케일 업 (scale up)** 보다
- 저가이면서 일반적인 성능의 하드웨어를 많이 나열해 전체 성능을 올리는 **스케일 아웃 (scale out)** 전략이 주류이다.

> 하드웨어 성능은 가격과 비례하지 않는다.

#### 규모 조정의 요소 - CPU 부하와 I/O 부하
- 스케일 아웃은 CPU 부하의 확장성을 확보하기는 쉽다.
- 이는 AP 서버에 해당한다 (애플리케이션 서버)
- DB 서버 측면에서는 I/O 부하가 걸린다.

#### 웹 애플리케이션과 부하의 관계
- 기본적으로 AP 서버에는 I/O 부하가 걸리지 않고, DB측에 I/O부하가 걸린다.
- AP 서버는 CPU 부하만 걸리기 때문에 분산이 간단하다.
- 대수를 늘리고, 로드밸런서를 이용해 적절히 분산하기만 하면 되기 때문에 간단하다.
- I/O 부하는 문제가 있다.
- 대수를 늘렸을때, 데이터의 동기화 문제, 쓰기는 간단히 분산할 수가 없다.

#### DB 확장성 확보의 어려움
- DB의 확장성 확보는 상당히 어렵다. 이는 디스크가 느리다는 문제도 한몫을 하고 있다.

#### 두 종류의 부하와 웹 애플리케이션
- 부하는 CPU 부하와 I/O 부하 두가지로 분류 된다.
- 대규모 계산을 하는 프로그램, 이는 I/O는 발생하지 않지만, 계산 속도에 의해 응답 시간이 좌지우지된다.
- 이는 CPU에 부하를 주는 프로그램이다.
- 디스크에 저장된 대량의 데이터를 검색하는 프로그램, 이는 디스크의 읽기속도에 의존한다.
- I/O에 부하를 주는 프로그램이다.

#### 멀티테스킹 OS와 부하
- 여러 OS가 멀티테스킹을 지원하지만, 이는 실제로 매우 짧은 시간간격으로 여러 테스크를 전환해가며, 멀티 테스킹을 실현한다.
- 테스크가 많아질수록,  특정 테스크가 처리중이라면 다른 테스크는 대기를 하게 되는데, '처리를 실행하려고 해도 대기한다' 라는 대기상태가 프로그램 실행 지연으로 나타난다.
- top의 출력 내용에 Load Average (평균 부하) 라는 수치가 포함되어 있다.
- Load Average 가 높을수록 테스크 실행에 대기가 발생하고 있다는 표시이다.

#### Average 가 보고하는 부하의 정체
- 하드웨어는 일정 주기로 CPU에게 인터럽트 신호를 보낸다.
- 주기적으로 보내는 신호라는 점에서 타이머 인터럽트라고 한다.
- 실행 중인 프로세스가 CPU를 얼마나 사용했는지 계산하는 등 시간과 관련된 처리를 한다.
- 커널은 타이머 인터럽트가 발생했을때 테스크 개수를 세어두고, 그 값을 단위 시간으로 계산한것이 Load Average로 보고 된다.