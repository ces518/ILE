# 마이크로 서비스 아키텍쳐

### 1.1 마이크로 서비스란 
- 작고 효율적으로 협업하는 서비스를 의미한다.

#### 1.1.1 작고 한가지일을 잘하는데 주력
- 명확하고 모듈화된 모놀리식 코드베이스를 유지하는것은 매우 어려운 일이다.
- 응집. 추상화. 모듈화는 MSA에서 중요한 개념이다.
- "같은이유로 변경되는것은 모으고, 다른이유로 인해 변경되는것은 분리해야한다."
    - SRP 단일 책임의 원칙
- 마이크로 서비스의 크기는 충분히 작아서 더 이상 작아질수 없는 크기라면 충분하다.
    

> 코드베이스란 ? 소프트웨어 시스템, 애플리케이션 에서 컴포넌트를 빌드하는데 사용되는코드 전체의 집합으로, 일반적으로 작성한 코드 파일을 의미한다.

#### 1.1.2 자율성
- 마이크로 서비스는 분리된 개체이다.
- PaaS (Platform as a Service) 상 격리된 서비스 또는 운영체제상 프로세스가 될 수 있다.
- 서비스간의 분산도는 높히고, 밀접하게 연결되어 생기는 문제점을 줄이기 위해 서비스간의 통신은 모두 네트워크 호출을 통해 이루어진다.
- 서로 독립적으로 변경 가능해야 하고, 사용자 수정 없이 배포 할 수 있어야한다.
- "무엇을 외부에 둘지, 무엇을 내부에 둘지에 대한 고민을 해야한다."
- 외부에 노출되는것이 많을수록 사용자와 협의해야할 것이 많아지기때문에 자율성이 떨어진다.
- 외부에 API를 공개하며, 이를 통해 상호 서비스들과 통신한다.

### 1.2 주요 혜택
- 마이크로 서비스가 제공하는 혜택은 많으면서도 다양하다.
- 대부분 다른 분산시스템에서도 제공하지만, 마이크로 서비스의 경우 분산시스템과 서비스지향 아키텍쳐의 개념을 더 깊기 내포하는만큼 더 많은 혜택을 누릴 수 있다.

#### 1.2.1 기술 이기종성
- 다수 서비스로 구성된 시스템의 경우 각 서비스가 다른 기술을 사용하도록 결정 할 수 있다.
- 만능의 접근 방식을 선택하기보다, 각 작업에 따라 적합한 도구를 선택할 수 있게 해준다.
- 시스템의 특정 성능을 향상 시켜야할때, 새로운 기술을 적용할때 마이크로서비스를 통해 더 신속히 적용이 가능하다.
- 새로운 기술을 시험하고, 도입할 때 최대 걸림돌은 잘 맞지 않을수 있다는 위험이다.
- 모놀리식 애플리케이션에서 새로운 기술을 적용하면 전체 애플리케이션에 영향을 미칠 것이다.
- 다양한 독립 서비스로 구성된 시스템에서는 새로운 기술분야를 적용할때 리스크가 적다.

#### 1.2.2 회복성
- 회복공학의 핵심은 격벽이다.
- 시스템의 컴포넌트가 장애가 나더라도 장애가 전파되지 않는다면, 해당 문제를 격리하고 시스템을 게속 작동할 수 있다.
- 서비스 전체 장애를 차단하고, 기능을 적절히 저하시키는 시스템 구축이 가능하다.
- 주의점: 향상된 회복력을 적절히 수용 할 수 있도록 분산 시스ㅔㅁ이 마주한 새로운 장애요인을 이해해야한다.

#### 1.2.3 확장성
- 모놀리식 애플리케이션에서는 항상 모든것을 함께 확장해야한다.
- 마이크로서비스 에서는 특정 서비스만 확장이 가능해 효율적인 자원 사용이 가능해진다.

#### 1.2.4 배포 용이성
- 모놀리식 애플리케이션은 한 줄만 수정되더라도 해당 버전을 릴리즈하기 위해서 전체 애플리케이션을 배포해야한다.
- 이는 막대한 영향을 끼치는 위험한 배포가 될 수 있다.
- 마이크로서비스를 이용하면 하나의 서비스만 변경할 수있고, 배포의 단위가 작아진다.
- 문제 발생시 해당 서비스만 롤백 함으로써 리스크를 최소화 할 수 있다.

#### 1.2.5 조직 부합성
- 마이크로서비스를 이용하면 아키텍처를 조직 구조에 맞게 더 적절히 정렬할 수 있다.
- 최적의 팀 크기와 생산성을 위해 하나의 코드베이스에서 일하는 인원을 최소화 할 수 있다.
- 서비스 소유권을 팀 간의 이전도 가능하다.

#### 1.2.6 조합성
- 분산 시스템과 서비스지향 아키텍처의 장점중 하나는 기능을 재사용할 기회가 많아진다는 것이다.
- 웹, 네이티브앱, 모바일 웹, 테블릿앱, 웨어러블장비 등을 위한 기능을 함께 엮을 무궁무진한 방법을 고민해야한다.

#### 1.2.7 대체 가능성을 위한 최적화
- 각 서비스가 작은 크기로 이루어져 있다면 교체비용을 줄일수 있으며 심지어 삭제도 쉽게 가능하다.
- 마이크로서비스는 대개 비슷한 크기로 이루어 지므로 서비스를 재작성 하거나 삭제하기 매우 쉽다.

### 1.3 서비스 지향 아키텍쳐란 
- Service-Oriented Architechture (SOA) 란 서비스의 최종 능력 집합 end set of capabilities 을 제공하는 여러**서비스**가 서로 협업하도록 설계 하는 접근 방식이다.
- SOA는 소프트웨어의 재사용성 장려를 목표로 한다. 둘 이상의 애플리케이션이 하나의 서비스를 사용할 수 있다.
- 서비스의 의미를 아주 많이 변경하지 않는한 이론적으로 다른서비스로 대체할 수 있어 유지보수와 재작성을 더 쉽게 한다.
- 실사용을 기반으로 출현한 마이크로서비스는 SOA에 적합한 시스템과 아키텍쳐를 더 잘 이해하게 해준다.
- 마이크로서비스는 SOA에 대한 특정 접근법으로 보아야 한다.

`서비스란 ?`
> 일반적으로 완전히 분리된 운영 시스템의 프로세스를 의미한다. 서비스 간 통신은 네트워크 호출로 이루어 진다.

### 1.4 기타 분해 기술
- 마이크로서비스 기반의 아키텍처의 수 많은 이점들은 마이크로서비스가 가진 세분화 특성과 문제해결을 위한 더 많은 선택의 기회를 제공하는데서 비롯된다.

#### 1.4.1 공유 라이브러리
- 모든 언어가 지원하는 표준 분해 기술은 코드베이스를 여러 라이브러리로 쪼개는 것이다.
- 이들 라이브러리는 서드파티 (외부) 에서 제공하거나 내부조직에서 만들 수 있다.

`단점`
- 1.진정한 기술 이기종성을 잃게 된다.
    - 일반적으로 라이브러리는 동일 언어에서 구현되거나 동일 플랫폼에서 실행되기 때문이다.
- 2.시스템 일부를 독립적으로 확장하기 힘들어 진다.
- 3.동적 라이브러리를 사용하지 않는 한 전체 프로세스를 재배포하지 않고서는 새로운 라이브러리를 배포할 수 없다. 변경부분만 격리하여 배포할 수 있는 능력이 떨어진다.
- 4.시스템 회복력을 보장하는 구조적 안전조치를 취할 명확한 접합부가 부족하다.

#### 1.4.2 모듈
- 일부 언어는 단순 라이브러라보다 뛰어난 독자적인 모듈 분해 기술을 제공한다.
- 이런 언어는 모듈의 수명주기 관리기능을 일부 제공한다.
- 프로세스를 종료하지 않고도 실행중인 프로세스에 변경된 모듈을 배포할 수 있다.

`OSGI`
- OSGI (Open Source Gateway Initiative) 는 모듈 분해를 실제로 구현해낸 대표적인 예다.
- OSGI 는 이클립스 자바통합 개발환경에 설치될 플러그인 프레임워크로 출현했고, 라이브러리를 통해 자바에 모듈 컨셉을 장착하는 방법으로 사용된다.
- 문제는 언어자체의 충분한 지원없이 수명주기 관리를 강제하려 한다는 점이다.

`Erlang`
- 얼랭 Erlang 은 모듈이 언어 런타임으로 생성된다.
- 이슈 없이도 멈추거나, 재시작하거나, 업그레이드 될 수 있다.
- 정해진 시간 내에 여러 버전의 모듈을 실행하는것을 지원한다.

> 이러한 역량을 가진 플랫폼을 사용하게 되더라도, 일반적인 공유 라이브러리를 사용할때의 결점은 여전히 존재한다.

> 한 프로세스 안에서 여러 모듈을 각각 서비스로 분해하더라도 그것이 모든 문제를 해결하지는 않는다.

### 1.5 은총알은 없다
- 마이크로서비스가 은총알도 아니며 황금망치로 오인되는 일은 없어야 한다.
- 분산 시스템과 연관된 모든 종류의 복잡성을 내포하고 있다.
- 모놀리식 관점에서 접근하고 있다면 배포, 테스트, 모니터링을 훨씬 더 잘다루어야 한다.


### 2.1 부정확한 비교
- 아키텍트는 통합된 기술적 비전을 확실히 확보하게 할 책임이 있으며, 고객이 필요로하는 시스템을 전달하도록 돕는 이들이다.
- 아키텍트들이 어떤 수준의 일을 하든지 간에 그들의 역할을 한마디로 정의하기는 쉽지 않다.
- 아키텍트는 구축하는 시스템의 품질 수준이나 동료들의 근무 조건, 변화에 대응하는 조직의 능력에 대해 직접적인 영향을 줄 수 있다.
- 엔지니어 또는 건축가와 비교한다면 부정확한 비교가 된다.

### 2.2 아키텍트에 대한 진화적 관점
- 아키텍트들이 요구사항은 건축가가 건물을 설계하고 짓는 것보다 훨씬 더 빨리 변경되고 도구와 기술도 원하는대로 변경할 수 없다.
- 결과물이 특정시점을 기준으로 고정되는 일은 없다.

> 고객의 손에 전해진 소프트웨어가 그대로 정체되는 일 없이 고객의 요구에 맞게 반응하고 적응해야 한다는 사실을 받아들여야 한다.

- 처음부터 완벽한 최종 제품을 만들려하기보다는 추가 학습을 통해 적합한 시스템이 생성되고 지속해서 성장할 수 있는 프레임워크를 만들어야한다.
- 아키텍트의 역할은 건축가보다는 도시 설계자에 가깝다.
- 특정 건물을 거기에 만들라고 하기보단 **도시를 구역화** 한다.

> 아키텍트는 개발자도 거주할 수 있는 시스템을 만들 의무가 있다.

### 2.3 구역화
- 아키텍트는 구역 내의 일 보다 구역 사이에서 발생하는 일을 더 걱정해야 한다.
- 서비스 간 통신방법에 대해 고민하거나 시스템의 전반적인 상태를 적절히 모니터링 하는데 더 많은 시간을 할애해야한다.

### 2.4 원칙적인 접근법
> 규칙은 바보에게는 복종이지만 현자에게는 지침이다 - 더글라스 베이더 -

- 시스템 설계상의 결정은 모두 트레이드 오프와 관련된다.
- 정보를 바탕으로 쉽게 내릴 수 있는 결정도 있지만, 그 결정이 불완전한 정보를 바탕으로 내려진 것이라면 ?
    - 여기서 도움되는 것이 구조화, 즉 프레이밍 이다.
    - 의사결정을 프레이밍 할 수 있는 가장 좋은 방법은 성취해야할 목표에 기반하여 일련의 원칙과 실천사항을 정의하는 것이다.

#### 2.4.1 전략적 목표
- 핵심은 전략적 목표가 조직이 지향하는 바와 일치해야 한다는 것이다.
- 회사의 기술 비전을 규정짓는 사람이라면 조직의 비 기술적인 부분에 많은 시간을 할애해야한다.

#### 2.4.2 원칙
- 원칙은 더 큰 목표를 이해 해야 할 일을 정렬하는 규칙으로, 때로는 변경될 수 있다.
- 원칙의 수는 10개 미만인 것이 좋다. 원칙이 많을수록 서로 겹치거나 모순될 가능성이 커진다.

#### 2.4.3 실천사항
- 실천사항은 원칙을 실행하는 방법으로, 업무 수행을 위한 자세하고도 실질적인 지침이다.
- 대개 기술 명세적이며, 어떤 개발자든 이해할 수 있도록 충분히 구체적이여야한다.
- 원칙과 마찬가지로 실천사항은 때때로 조직의 제약사항을 반영한다.
- 또한 아키텍트의 원칙을 뒷받침 해야한다.

#### 2.4.4 원칙과 실천 사항의 결합
- 누군가의 원칙이 다른 사람에게는 실천 사항이 될 수 있다.
- 작은 그룹에서 원칙과 실천사항을 결합하는 일은 문제가 되지 않지만
- 큰 조직의 경우 공통된 원칙을 지향하면서 기술과 실천사항이 서로 다를 수 있으며 장소에 따라 다른 요소가 필요할 수도 있다.

#### 2.4.5 실제 사례
- 목표와 원칙, 실천사항을 다이어 그램으로 만든다.
- 다디어그램은 목표, 원칙, 실천사항을 명료하게 보여준다.
- 각 개념은 일반 개발자가 이해하기에도 충분할 만큼 단순하다.
- 각 항목에는 세부사항이 뒤따르지만, 이 처럼 요약된 양식으로 명확히 설명하는 것은 매우 유용하다.

### 2.5 필수 기준
- 트레이드오프에 대해 고민할 때 찾아아야할 핵심 균형중 하나는 시스템이 얼마나 많은 변화를 허용할 수 있는가 이다.
- 서비스와 서비스간에 어떤 부분이 일정해야하는지 식별하는 방법중 하나는 바람직하게 동작하는 서비스의 모습을 정의하는것이다.

> 각 서비스가 가져야 할 명확한 속성을 정의하는 것

#### 2.5.1 모니터링
- 서비스 간 경계를 넘어 시스템의 상태를 일관되게 살펴 볼 수 있어야 한다.
    - 서비스 세부상태가 아닌 시스템 전체상태를 볼 수 있어야 한다.
- 어떤 것을 선택하든 표준을 유지해야 한다.
- 박스 안의 기술을 불투명하게 만들고, 모니터링 시스템을 지원한다는 이유로 이를 변경하지 않아야 한다.
- 로깅 역시 모니터링과 같은 범주에 속하며, 한 곳에서 수집되어야 한다.

#### 2.5.2 인터페이스
- 서비스간 인터페이스 기술의 개수는 가능한 최소로 유지하는것이 새로운 서비스를 통합하는데 도움이 된다.
- 단순히 기술을 선택하는 문제가 아니다.
- HTTP/REST 를 택한다면, 동사형이나 명사형 가운데 어느 쪽으로 쓸지, 어떻게 리소스 페이징처리를 할 것인지, 엔드포인트의 버전은 어떻게 구분할 것인지 고려해야 한다.

#### 2.5.3 아키텍쳐 안정성
- 아키텍트는 오작동하는 하나의 서비스가 전체를 망가뜨리게 해서는 안되며, 서비스들이 비정상 적인 하위 호출로 부터 자신을 보호해야 한다.
- 응답코드가 규약대로 동작하는것이 중요하다
- 에러에 대해 요청성공을 뜻하는 2XX응답을 보낸다거나, 4XX, 5XX 응답을 혼동한다면 안전조치가 무너진 것이다.
- 요청을 빠르게 실패시켜 문제를 추적하도록 만드는 방법이다.
- 시스템이 빠르게 동작하더라도 이러한 규칙에 대해 엄격하지 않다면 취약한 시스템으로 남게된다.

`하위호출 downstream call`
- 통신의 흐름에서 상위 통신 매체로부터 하위 통신 매체로 전해지는 데이터
- 그 반대는 상향 호출 upstream call 이다.
- 일반적인 서버-클라이언트 전송방식에서 상류: 서버, 클라이언트는 하류로 지정하며 서버에서 클라이언트로 가는 데이터를 지칭한다.

### 2.6 코드를 통한 통제
- 함께 모여 일을 수행하는 방식을 합의하는것은 좋은 아이디어 이지만, 이러한 지침을 따르게 하는것은 매우 힘든일이다.
- 개발자에게 우리가 바라는 각서비스의 표준을 구현하도록 부담을 주기 때문이다.
- 옳은 것을 쉽게 행하게 하는 것에 대한 효과적인 두 가지기술은 모범사례, 서비스 템플릿을 제공하는 것이다.

#### 2.6.1 본보기
- 문서로 기록하는것은 매우 바람직하며 유용하다.
- 시스템의 더 나은 부분을 모방하는 것만으로도 사람들은 큰 실수를 예방할 수 있다.

#### 2.6.2 맞춤형 서비스 템플릿
- 드롭위자드와 카욘은 JVM기반 오픈 소스 마이크로 컨테이너 이다.
- 상태 점검과 HTTP지원, 지표 산출 등의 기능을 제공하기 위해 서로 유사하게 일련의 라이브러리와 협업한다.
- 내장형 서블릿 컨테이너가 완비된 서비스를 바로 사용할 수 있다.
- 우리에게 맞는 개발 실천 사항에 대한 서비스 템플릿을 맞춤화하면 팀은 더빨라지고 개발자들도 서비스가 잘못된 행위에 빠지지 않게 방어할 수 있다.
- 다수의 이질적인 기술 스택을 상요할 수 있다면 각 기술 스택에 대응하는 서비스 템플릿이 필요하다.
- 하지만 이것은 교묘하게 팀의 언어 선택을 제한할 수 있다.
- 새로운 기술 스택 도입을 하는 누구나 노력을 반복해야 하는데 넷플릭시는 새로 도입된 기술에 대한 중복된 노력을 줄일수록 시스템이 잘못되기 더 쉽다는 사실에 주목한다.
- **사이드카 서비스**를 사용함으로써 이러한 위험을 완화한다.
- 서비스 템플릿을 만드는 일이 작업 방식을 지시하는 아키텍쳐 팀이나 중앙집권적 도구의 업무가 되지않도록 주의해야 한다.
- 맞춤형 서비스 템플릿을 사용하기로 했다면 매우 조심스럽게 다뤄야 한다.
- 재사용가능한 코드를 갈망하는 우리는 서비스 간의 결합을 일으키는 근원을 유입할 수 있다.

`사이드카 서비스`
- 오토바이 옆에 부착되는것 처럼 부모 서비스에 부착되어 별도 프로세스로 동작한다.
- 서비스 검색, 동적구성, 회복력 있는 서비스 간 통신과 같은 플랫폼 인프라스트럭처 기능을 동일한 인터페이스를 통해 JVM기반이 아닌 서비스에도 제공할 수 있다.
- 넷플릭스 에서는 프라나 (Prana) 를 사용한다.


### 2.7 기술부채
- 때로는 몇몇 긴급한 기능을 배포하기 위해 절차를 무시한 선택을 해야하는데 이것은 우리 스스로 처리해야할 하나의 트레이드 오프 이다.
- 기술 비전에는 존재 이유가 있다.
- 그 이유에서 벗어날 경우 단기적으론 이득일수 있어도 장기적으로는 비용이 발생할 수 있다.
- 이런 트레이드 오프를 이해하도록 돕는 개념이 바로 기술부채 이다.
- 단지 손쉬운 방법을 택했다는 이유만으로 발생하는것이 아니라 변경된 시스템의 비전이 모든 시스템과 잘 어울리 않는다면 이 또한 새로운 기술부채의 원인이 된다.

### 2.8 예외처리
- 원칙과 실천사항은 시스템 구축 방법을 안내한다.
- 충분히 많은 예외가 발견된다면 결과적으로 현실을 재인식시킬수 있도록 원칙과 실천사항을 변경하는것이 타당할 수 있다.

### 2.9 중앙에서의 거버넌스와 지휘
- 아키텍트의 담당 업무 중 하나는 **거버넌스(governance)** 이다.
- 아키텍트의 업무중 하나가 기술 비전을 결정하는 것이라면, 거버넌스는 우리가 구축하는 결과물이 해당 비전과 일치함을 보장하고, 필요할 경우 비전을 진화시키는 것이다.
- 또한 아키텍트는 최신 기술을 유지하고, 올바른 트레이드 오프를 결정해야한다.

`거버넌스(governance)`
- 기업의 목적이 이해관계자의 요구, 조건, 선택을 평가함으로써 달성될 수 있음을 보장한다.
- 우선순위 및 의사 결정을 통해 방향을 설정하고, 합의된 방향과 목표에 대한 성과, 준수, 과정을 모니터링한다.

### 2.10 팀 만들기
- 기술 리더의 역할을 사람들이 스스로 비전을 이해하도록 그들의 성장을 돕고, 비전을 결정하고, 구현하는데 적극적으로 참여할 수 있도록 만드는 것이다.

### 2.11 마치며
진화적 아키텍트의 핵심 책무
- 비전
    - 명료하게 소통되고, 시스템이 고객과 조직의 요구사항을 충족하도록 돕는 기술 비전이 있는지 확인하라.
- 공감
    - 고객과 동료에 대한 여러분 결정의 파급력을 이해하라.
- 협업
    - 비전을 정의하고, 다듬고, 실행하기 위해 가능한 한 많은 동료와 협업하라.
- 적응성
    - 기술 비전이 고객과 조직이 요구하는 것을 반영하는지 확인하라.
- 자율성
    - 여러분의 팀의 표준화와 자율성 사이에서 올바른 균형을 찾아내라.
- 거버넌스
    - 시스템이 기술 비전에 맞게 구현되고 있는지 확인하라.

- 진화적 아키텍트란 끊임없는 갈등 조정 과정을 통해 이러한 위업이 달성된다는 것을 이해하는 사람이다.


### 서비스 모델링 하기

### 3.1 뮤직코퍼레이션 소개
- 가상의 도메인에 다루며 마이크로서비스의 개념이 현실세계에서 어떻게 작용하는지 살핀다.

### 3.2 무엇이 좋은 서비스를 만드는가 ?
- 두가지 주요 개념에 집중하라
- 느슨한 결합(loose coupling), 강한 응집력(high cohesion)
- 이 두 개념이 잘못되면 나머지도 의미가 없다.

#### 3.2.1 느슨한 결합
- 서비스가 서로 느슨히 결합되어 있다면 하나의 서비스가 변경될때 다른 서비스가 변경되는 일이 없다.
- 마이크로서비스의 요점은 시스템의 그 어떤 부분도 추가 변경할 필요 없이 특정 서비스를 변경하고 배포할 수 있다.
- 느슨하게 결합된 서비스는 그와 협업하는 서비스에 관해 알 필요가 없다.
- 과도한 커뮤니케이션은 잠재적인 성능 문제를 넘어 강한 결합을 초래할 수 있기 때문이다.

`강한 결합을 일으키는 요인`
- 서비스를 서로 강하게 엮어 버리는 통합방식을 택하는 것
- 이런 방식의 서비스의 내부 변경 곧 해당 서비스의 사용자 변경까지 야기하게 된다.

#### 3.2.2 강한 응집력
- 연관된 행위는 한데 모아두고, 그렇지 않은것은 다른곳에 두고 싶어한다.
- 특정 행위를 변경하고자 할 때는 한 곳에서 변경가능하고 강능한 한 신속하게 릴리즈 할수 있기 때문이다.
- 여러곳에서 행위를 변경해야 한다면 해당 변경사항을 적용하기 위해 많은 서비스를 릴리즈 해야 할 것이다.

### 3.3 경계가 있는 콘텍스트
- 모든 도메인은 다수의 경계가 있는 콘텍스트로 구성되며, 각 콘텍스트 내에는 외부와 통신할 필요가 없는 것 뿐 아니라, 다른 콘텍스트와 공유되는 것이 함께 존재한다.
- 모든 콘텍스트에는 명백한 인터페이스가 존재하며, 그것은 어떤 모델이 다른 콘텍스트와 공유될지 결정한다.
- 경계가 있는 콘텍스트의 또 다른 정의는 "명료한 경계에 의해 강제된 구체적인 책임"
- 만약 콘텍스트로 부터 정보를 원하거나, 내부의 기능을 요청하고자 한다면 모델을 이용하여 콘텍스트 경계와 의사소통 해야한다.

#### 3.3.1 감춰진 공유 모델
- 뮤직코퍼레이션의 경우, 재무부서와 창고를 서로 분리하는 경계가 있는 컨텍스트로 생각할 수 있다.
- 두곳 모두 외부 세상에 명시적인 인터페이스를 제공하며, 각자만 알고 있어야할 세부사항이 있다.
- 재무부서는 창고 내부의 세부 업무에 대해 세세하게 알 필요는 없지만, 적어도 몇가지는 알아야한다.
- 재고 수준에 따라 장부를 업데이트 하는 것과 같은 일이다.
- 창고 콘텍스트에 있는 재고 품목의 모든 것을 노출할 필요는 없다는 점을 주목하라.
- 재고 품목에 내부적인 것을 기록하더라도 창고 내에서만 유지되며, 공유 모델에 노출할 필요는 없다.
- 그에 따라 내부 전용 표현과 노출하는 외부 표현으로 구분할 수 있다.

> 가끔 서로 다른 콘텍스트에서 의미는 완전 다르지만 이름이 같은 모델들을 접할수 있다. 고객 -> 반품과 창고 -> 반품과 같은 케이스가 이와같은 예다.

- 재무 부서와 창고 사이의 공유 모델
`재무부서`
- 재고 보고서
- 총계정원장
- 회사평가

`공유모델`
- 재고 품목

`창고`
- 카트
- 주문수집자
- 주문선택
- 재고품목
- 선반

#### 3.3.2 모듈과 서비스
- 어떤 모델을 공유해야하는지, 어떤 내부 표현을 공유하면 안되는지 명확하게 고려함으로써 강결합을 초래하는 잠재적 함정중 하나를 회피한다.
- 서로 조화를 이루는 비즈니스 역량들이 존재하는 도메인 내부의 경계를 식별하며 높은 응집력을 제공한다.
- 경계가 있는 콘텍스트는 구성요소의 경계구분에 매우 적합하다.
- 관련 코드를 모으고, 시스템 내 다른 모듈과의 결합도를 낮추기 위해 프로세스 경계 내에서는 모듈을 사용할 수 있다.
- 도메인에서 경계가 있는 콘텍스트들을 발견했다면 공유되고 감춰진 모델을 이용하여 코드 내에서 모듈로 모델링 하라.
- 모듈의 경계는 마이크로서비스의 훌륭한 후보이다.
- 마이크로서비스는 경계가 있는 콘텍스트와 완전히 정렬되어야 한다.

### 3.3.3 성급한 분해
- 시스템을 마이크로서비스로 성급하게 분리하면 막대한 비용이 소요될 수 있다.
- 특히 도메인에 대한 경험이 없다면 더더욱 그렇다.
- 기존 코드베이스를 마이크로서비스로 분해하는 것이 처음부터 마이크로서비스로 가는것 보다 쉽다.

### 3.4 비즈니스 능력
- 경계가 있는 콘텍스트에 대해 고민할떄는 공유 데이터 관점이 아닌 나머지 도메인을 제공하는 콘텍스트의 능력 관점에서 봐야한다.
- 예를 들어 창고와 재무 콘텍스트 이다.
- 이들의 능력은 정보의 교환이 이루어 지는 공유 모델을 필요로 할 수 있으나, 데이터에 대한 생각이 빈약한 CRUD 기반 서비스를 초래하는 것을 자주 목격했다.
- 이 콘텍스트는 무엇을 하는가? 와 그 일을 하기위해 어떤 데이터가 필요한가? 를 먼저 생각해라.
- 이들 능력이 서비스로 모델링 될 때 그것은 네트워크를 통해 다른 협업자에 노출될 주요 행위가 된다.

### 3.5 거북이 밑에 거북이
- 경계가 있는 콘텍스트들은 더 많은 경계가 있는 컨텍스트 들을 내포할 수 있다.
- 예를 들어 창고 를 주문조달과 재고관리 또는 제품 인수와 연관된 기능으로 분해할 수 있다.
- 마이크로서비스의 경계를 고려할 때는 더 **넓고 큰 단위의 콘텍스트 관점에서 생각한 뒤 접합부의 분리를 통한 혜택을 발견했을때 내포된 콘텍스트에 따라 세분화 하라.**
- 단일하게 창고 콘텍스트를 만드는것 보다 주문조달, 제품인수, 재고 품목으로 경계를 분리할 수 있다.
- 완전 분리 방식 대신 내포된 방식을 선택한느 것은 조직구조를 기반으로 결정해야 한다.
- 주문 조달, 재고 관리, 제품 인수가 **각각 다른 팀에 의해 관리가 이루어 진다면 최상위 계층의 마이크로서비스 후보이다.**
- 반면 한팀에 의해 관리된다면 내포 모델이 더 합리적 일 것이다.
- 내포 방식을 선호하는 또 다른 이유로는 테스팅의 단순화를 위해 아키텍처를 큰 덩어리를 묶을 수 있다.
- 창고를 소비하는 서비스를 테스트할 떄는 창고 콘텍스트 내에 각각 서비스에 대해 스텁을 만들 필요없이 더 큰단위의 API를 테스트하면 된다.
- 더 큰 범위의 테스트를 고려할 때 분리단위로 활용될 수 있다.
- 창고 콘텍스트 내의 모든 서비스를 실행하는 엔드 투 엔드 테스트를 수행할때는 다른 모든 현업자를 위해 각 서비스의 스텁을 준비해야 한다.

`스텁(Stub)`
- 메서드 스텁이라고 하며, 다른 프로그래밍 기능을 대리하는 코드다.
- 스텁은 기존 코드(원격 머신의 프로시저 등)를 흉내내거나 아직 개발되지 않은 코드를 임시로 대치하는 역할을 한다.
- 일반 소프트웨어 개발과 테스팅을 포함해 이식과 분산 컴퓨팅에 유용하다.

### 3.6 비즈니스 콘셉트 관점에서의 커뮤니케이션
- 시스템에 구현하는 변경사항은 종종 비즈니스가 시스템의 동작방식을 변경하려는 경우이다.
- 도메인을 대표하는 경계가 있는 콘텍스트들에 따라 우리 시스템이 분해된다면 변경사항은 마이크로서비스 경계로 격리되기 쉽다.
> 변경사항을 줄이고 신속한 배포가 가능하다.
- 비즈니스 도메인에 기반을 둔 소프트웨어 모델링은 경계가 있는 콘텍스트 개념에서 멈춰서는 안된다.

### 3.7 기술적 경계
- 기술 접합부에 따라 서비스 경계를 모델링하는것이 항상 잘못된것은 아니다.
- 조직이 특정 성능 목표를 달성할 떄 수평으로 나누는 방식이 더 적절하다
- 하지만 이는 기술 접합부를 찾는 첫 번째 목표가 아닌 두 번째 목표가 되어야 한다.

### 3.8 마치며
- 경계가 있는 콘텍스트는 이들 접합부를 찾는데 중요한 도구고, 마이크로서비스를 이 경계에 정렬하여 우리의 최종시스템이 온전한 장점들을 유지하도록 만들어야 한다.

### 4.1 이상적인 통합 기술 모색
- 하나의 마이크로서비스가 다른 마이크로서비스와 통신하는 방법은 매우 다양하다.
- SOAP, XML-RPC, REST, 프로토콜 버퍼 등..

#### 4.1.1 호환성을 깨트리는 변경 피하기
- 개발자에 의한 변경은 서비스 소비자 측의 변경까지 초래하는 결과를 가져온다.
- 가능하면 이러한 변경을 일으키지 않는 기술을 선택해야 한다.

#### 4.1.2 기술 중립적인 API 생성
- 새로운도구, 프레임워크, 언어가 계속 쏟아져나와 더빠르고 효과적으로 일할 수 있는 아이디어를 구현하게 해준다.
- 마이크로서비스간의 통신에 사용되는 API가 특정 기술에 종속되지 않도록 기술 중립성을 유지하는 것을 매우 중요하게 생각하는 이유이다.
- 이는 통합 기술을 회피하는 것을 의미한다.

#### 4.1.3 소비자를 위한 서비스 단순화
- 소비자가 마이크로서비스를 사용하는데 엄청난 수고를 들여야 한다면 심미적으로 구조화된 마이크로서비스를 만드는 일은 그리 중요하지 않다.

#### 4.1.4 내부 구현 상세 감추기
- 소비자가 우리의 내부에 종속되기를 원치 않는다.
- 내부에 종속되면 결합도가 높아지고, 마이크로서비스 내부를 변경할 때도 소비자에게 변경까지 요구하며 호환성을 깨드릴 수 있다.
- 내부의 세부 표현을 외부로 노출하도록 강요하는 그 어떤 기술도 피해야한다.
