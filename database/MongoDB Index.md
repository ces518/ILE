# MongoDB Index

## Index 란 ?
- 책의 인덱스와 데이터베이스의 인덱스의 공통점 ?
  - 핵심된 키워드
  - 정렬되어 있음
- 데이터베이스에서 테이블에 대한 동작 속도를 높혀주는 자료구조
- 특정 필드를 기준으로 정렬해서 보관한다.
- Write 성능을 손해보는 대신, Read 성능을 향상

## MongoDB Index 의 종류
- **Regular Index 일반적인 인덱스**
- Geospatial Index 지구 공간정보
- Text Index 문자열에 대한 텍스트 검색 쿼리
- Hashed Index 해싱된 값 저장
- Mutikey Index 배열의 각 요소에 대한 검색
- TTL Index 보관기간이 지난 도큐먼트 자동 삭제
> MongoDB 의 Index 는 모두 B+ Tree 로 구현되어 있다.

### B - Tree
- 자식 노드가 2개 이상인 트리
- 이진 트리의 확장 개념이다.
- 하나의 노드에 다수의 값을 저장하여 검색 성능을 향상시킨다.
- 순차 검색 효율이 낮다.

### B + Tree
- B - Tree 의 단점을 보완
- Leaf Node 가 Linked List 로 연결된 구조
- 모든 데이터는 Leaf 노드에 저장된다.
  - Root 와 Branch Node 는 Key 의 역할만 수행한다.
- 랜덤 검색, 순차 검색의 절충안이다.
- 균등한 응답속도를 보장한다.
- 노드의 접근 횟수를 감소시킨다.
> DBMS 에서 가장 널리 사용되는 인덱스 자료구조

## Index 설계

### 복합 인덱스 (Compound Index)
- 2개 이상의 필드를 기준으로 한 인덱스
- **선행 필드를 기준** 으로 우선 정렬된다.
- 쿼리 조건에 후행 필드만 존재할경우, **인덱스 사용 불가**
> 선행 필드를 선정하는 것이 중요하다.

### 인덱스 설계 전략
1. Query 를 Support 하는 인덱스를 만들것
  - 인덱스가 쿼리의 조건 필드를 모두 포함하는 경우, Query 를 Support 한다고 표현한다.
  - Query 를 Support 하는 인덱스를 만들면 성능이 크게 향상된다.
2. 인덱스를 사용하여 쿼리 결과를 정렬하라
  - 인덱스를 사용하여 정렬할 수 없는 경우, 메모리 상에서 정렬이 수행된다.
  - 즉 오버헤드가 크고, 크기 제한도 있으며 권장하지 않는다.
3. 인덱스의 선택도를 높혀야 한다.
  - 인덱스를 사용하여 쿼리의 결과를 좁힐수 있는 정도

### 효율적인 인덱스 설계를 위한 고려 사항
1. 인덱스 선택도 - 인덱스를 통해 쿼리 결과 범위를 좁혀야 한다.
  - 인덱스 카디널리티가 높은가 ?
  - 키 분포가 고른가 ?
2. 복합 인덱스의 필드 순서를 잘 선정해야 한다.
  - 인덱스의 선택도가 높으 순서대로
  - 쿼리 조건은 **ESR-Rule** 을 기본으로 따른다.

### 선택도와 인덱스 카디널리티
- 인덱스 카디널리티란?
    - 인덱싱 필드의 **고유한 값의 개수**
- 인덱스 카디널리티가 낮다 == 인덱싱 필드에 고유한 값이 적다

| 필드 | 도메인 | 카디널리티 |
| --- | --- | --- |
| 성별 | 남/여 | 2 |
| 알파벳 | A-Z | 26 |
| 점수 | 0-100 | 101 |

- 카디널리티가 높은 필드에 인덱스를 설정하는것이 효율적이다.
- 카디널리티가 낮은 경우 인덱스 스캔이 컬렉션 풀스캔보다 비효율적일수 있다.
- 인덱싱 필드의 값이 정규 분포인 경우, 카디널리티와 인덱싱 효율은 비례한다.
- 필드의 분포가 특정 값에 몰려있다면, 인덱스 효율이 낮아질 수 있다.
> 선택도를 결정짓는 기준은 카디널리티, 키 분포

### 필드 순서와 선택도
- 선택도가 높은 필드부터 순서대로 설정하는 것이 효율적이다.
- 선행 필드에 가능한 데이터를 많이 거를 수 있도록 고려해야 한다.
- 노드 하나에 인덱싱 필드와 후행 필드가 같이 들어있다는 것을 유의 해야한다.

## 필드 순서와 쿼리 조건

### 쿼리 조건
- Equality
- Range
- Sort
  - Sort 는 정렬 조건이므로 데이터의 범위를 좁힐 수 없다.
  - 선행 필듣가 Sort 라면, 이는 무시되고 후행 필드로 넘어가게 된다.

### ESR Rule (Equality Sort Range)
- E-S-R 인 순서대로 인덱싱 필드를 설정하는 것이 효율적이다.
- E-R-S 순으로 인덱스를 설계하면, 노드에 접근하는 횟수만 봤을땐 더 효율적으로 보일 수 있다.
- 하지만 E-S-R 로 설계 했을때 상대적으로 노드 접근 횟수가 더 많을 순 있으나, 데이터 셋을 찾은 뒤 이미 정렬이 되어 있는 상태
- E-R-S 순으로 인덱스를 설계 했다면, 메모리에서 정렬하는 작업이 추가적으로 필요한데, 이 작업이 오히려 노드를 몇개 더순회하는것 보다 비용이 더 크다.
> 항상 모든경우에 ESR 룰이 최고인것은 아니다.

- E 조건이더라도 선택도가 좋지않으면, 인덱스에 빠지는 경우도 있으며, Range 조건이 선택도가 좋은경우 Sort 보다 앞에 위치하기도 한다.

## 예제
```sql
// Query
db.books.find({
	"uuid": 8357,
	"author_id": 1436,
	"category": "A",
	"is_display": true,
	"hits": { $lte: 3 },
}).sort({ "created_at": 1, "last_modified_at": -1 });
// 선택도 : uuid > author_id > category > hits > is_display

// Index
db.books.createIndex({
	"uuid": 1,
	"author_id": 1,
	"category": 1, // is_display 는 Equality 지만 선택도가 낮기 떄문에 제외시킴
	"created_at": 1,
	"last_modified_at": -1,
	"category": 1
})
```

## 인덱스에 대한 오해와 진실

### 인덱스 스캔이 항상 좋은것은 아니다.
- 데이터 개수가 적거나, 인덱스로 쿼리 결과의 범위를 거의 좁힐 수 없을 경우 컬렉션 풀스캔이 더 빠르다.

### 최대한 쿼리를 합치는것이 효율적인 것은 아니다.
- or, in, ne 와 같은 조건들은 인덱스 효율이 매우 좋지 않다.
- 차라리 여러 쿼리로 나누어 호출하는 것이 효율적일 수 있다.

### 모든 쿼리에 대해 인덱스를 하나씩 만들면 좋은가 ?
- 인덱스가 너무 많으면 DB 성능 하락 유발
- Write 성능 하락
- 빈번한 메모리 스왑 발생

## Bad Query

### OR 조건
- OR 조건의 사용 필드가 다르면, 2개 이상의 인덱스를 사용한 뒤 결과를 병합하는 방식으로 동작한다.
  - 이는 쿼리의 수행 시간 증가로 이어짐
  - 쿼리가 복잡해질수록 제대로된 인덱스를 선정하지 못하는 문제 발생
  - 쿼리 분리 혹은 스키마 튜닝을 권장
  
```sql
db.users.find({
	$or: [
		{"name": "Ace", "age": 30},
		{"name": "Bob", "gender": "M"}
	]
})
```

### IN 과 NE 조건
- in, ne 조건을 사용하면 인덱스 스캔 범위를 특정할 수 없다.
- 조건 내에 존재하는 키의 개수만큼 인덱스 스캔을 N 회 수행하게 된다.
  - 이는 속도 저하의 원인
- 쿼리 분리 or 스키마 튜닝을 권장

### 정규 표현식 조건
- 문자열 필드에 정규 표현식을 사용하는 경우가 많다.
- 인덱스는 문자열의 좌측을 기준으로 정렬된다.
- 부분검색시 인덱스를 타지 못하고 컬렉션 풀 스캔을 하게 된다.
- 위와 같은 경우 텍스트 인덱스로 구성을 해야한다.

### SKIP + LIMIT
- 페이징 혹은 배치처리시 주로 사용한다.
- skip(9990).limit(10)
- 위 쿼리는 9990개를 읽고 버린뒤 10개를 반환하는 방식으로 동작한다.
  - 부하의 원인
- Range 조건으로 조금씩 범위를 나누어 가져오는 방법 권장
- 쿼리 결과의 마지막 id 를 기억해둔 뒤 다음 쿼리때 해당 id 기반으로 더큰 아이디 조회 등...

## Query Plan
- 쿼리 실행시 데이터에 접근하고 다루는 작업의 순서
- 주요 작업
  - IXSCAN : 인덱스 스캔, 인덱스를 사용하여 데이터를 조회
  - COLLSCAN : 컬렉션 풀스캔, 적절한 인덱스가 없는 경우

### explain()
- MongoDB 실행 계획 확인
- db.collection.find().explain()
- db.collection.explain().<method()>

```sql
// 인덱스가 존재하는 필드 조회시
{
	"queryPlanner": {
		... 
	},
	...
	"winningPlan": {
		"stage": "FETCH",
		"inputStage": {
			"stage": "IXSCAN"
			...
		}
	}
}

// 인덱스가 없는 경우
{
	"queryPlanner": {
		... 
	},
	...
	"winningPlan": {
		"stage": "FETCH",
		"inputStage": {
			"stage": "COLLSCAN"
			...
		}
	}
}
```

## Shard Key
- 클러스터의 샤드 간 컬렉션 도큐먼트의 분포를 결정하는 **인덱싱 필드**
- 샤드 내에 존재하는 데이터 집합을 Chunk 라고 한다.
- Chunk 들은 데이터 집합을 균등하게 분배하고, 샤드는 Chunk 의 개수를 균등하게 유지한다.
- Shard Key 필드를 조건으로 하는 쿼리를 날리면, MongoS 가 각 샤드가 어디에 위치하는지 알고 있다.
- 이러한 쿼리를 타겟 샤드가 정해져 있다고 해서, Targeted Query 라고 한다.
  - Targeted Query 라면, 최적의 경우 3000QPS 가 들어와도 1000QPS 씩 부하가 분산된다.
- Shard Key 필드가 아닌 조건으로 하는 쿼리를 날리면 어떤 샤드에 위치하는지 모르기 때문에, 모든 샤드에 쿼리를 날리게 됨
  - 이러한 쿼리를 Broadcast Query 라고 한다.
  - 3000QPS 가 들어왔다면 모든 샤드에 3000QPS 가 전파된다.

### 효율적인 샤드키 조건
- Large Cardinality (다양한 값을 가지는 필드, 값의 가짓수가 많아야 한다.)
- Low Frequency (특정 값에 몰리지 않고 골고루 값이 분포되어 있어야 한다.)
- Non-Monotonically Change (값이 단조적으로 증가하거나 감소하기만 하지않아야 한다.)

### Shard Key Cardinality : 샤드키의 고유한 값의 개수
- **하나의 값은 하나의 청크에만 저장** 이 가능하다.
  - 하나의 값은 하나의 샤드에만 저장가능하다는 의미
- 카디널리티가 낮은 경우 아무리 샤드를 늘려도 수평 스케일링의 이점이 없다.
- 카디널리티가 낮은 경우 어느 순간 청크의 보관 가능 크기를 초과한다. (점보 청크)
  - 점보 청크를 만드는 상황을 피하는것이 중요하다.
- 카디널리티가 낮은 필드를 샤드키로 해야한다면, 후행필드를 붙여 이를 완화한다.
  - 완화책은 복합인덱스

### Shard Key Frequency : 주어진 값이 발생한 빈도
- 대부분의 도큐먼트가 특정 샤드키 값만 가지는 경우
- 하나의 샤드로 트래픽이 몰린다 -> 병목 현상 발생
- 청크의 보관 가능 크기를 초과한 -> 점보 청크
> 샤드 키에 다른 필드를 추가해, 분포도를 높혀야 한다.

### Monotonically Change : 값이 단조적으로 증가하거나 감소하는 경우
- 1, 2, 3, 4 와 같이 순차증가 (Auto-Inc)
- 항상 특정 샤드에만 데이터가 삽입된다.
- Insert 성능 하락
- 샤드간 잦은 데이터 이동 발생
> Hashed Sharding 을 사용해야한다.

## 샤딩 방법

### Range Sharding
- 샤드 키 값을 기준으로 범위를 나누어 샤딩
- 샤드 키 값을 변형하지 않고, 그 자체로 정렬됨
- 장점
  - 복합 인덱스를 샤드키로 설정 가능
  - Range 쿼리를 타겟 쿼리로 실행이 가능
- 단점
  - 각 샤드에 데이터가 균형있게 분산되지 않을 가능성이 높다.

### Hashed Sharding
- 샤드 키 값의 해시 값으로 범위를 나눈뒤 샤딩
- 장점
  - 데이터 불균형 문제 완화
  - 초기에 빈 청크들을 미리 만들어 둘 수 있다.
- 단점
  - **복합 인덱스를 샤드키로 설정이 불가능하다. (~ v4.2)**
    - 이는 치명적..
  - Range 쿼리는 브로드캐스트 쿼리로 발생하게 된다.

### v4.2 이하 에서 해시 샤딩 모방하기
- account_id 를 샤드키로 사용하고 싶다면, account_id의 해시 값을 새로운 필드로 생성
- 복합 샤드키 (hashed_account_id, account_id, ...) 로 Range Sharding

## 샤드키 제약 사항
- 샤드키를 포함하지 않는 쿼리
  - 브로드 캐스트 쿼리로 동작한다.
  - 대부분의 쿼리가 샤드키를 포함하지 않는 경우 샤딩으로 인한 부하분산을 기대하기 어렵다.
  - in 조건, 해시 샤딩시 range 조건도 유의 (브로드캐스트 쿼리나 마찬가지임..)
- 유니크 제약조건은 단일 샤드내에서만 보장된다.
- 샤딩된 컬렉션에서 유일성이 보장되는 경우 3가지
  - 샤드키
  - 샤드키가 가장 앞에 있는 복합 인덱스
  - default_id index (Object id 타입)
- 샤드키는 변경이 불가능
- 샤드키를 변경해야 하는 경우 컬렉션 드랍 & 재생성
- v4.4 부터는 기존 샤드키에 다른 필드 추가가능
  
  