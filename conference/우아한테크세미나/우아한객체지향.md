# 우아한 객체지향
- 설계 ? -> 코드를 어떻게 배치할 것인가.
    - 클래스, 패키지, 프로젝트 각각에 어떤 코드를 배치할 것인가
    - 변경에 초점을 맞추는것이 중요하다.
    - 같이 변경되는 것들을 같이 놓아야 한다.
    - 핵심은 의존성.

## 의존성 (Dependency)
의존성은 A 가 B 에 의존 할경우 
A ----> B (점선으로 표기하는것이 핵심)
> B가 변경될때 A 가 변경될 수도 있다.
> **변경될 가능성** 이 있음을 얘기하는것이 의존성이다.
> 의존성이 있다고해서 무조건 바뀌는것은 아니다.

클래스, 패키지 의존성으로 크게 나뉜다.

### 클래스 의존성
1. 연관관계 
   - A -> B 로 객체 참조를 가지고 있다.
2. 의존관계
   - 파라미터, 리턴타입, 메소드내에서 해당 타입 인스턴스를 생성하는 경우 의존관계이다.
   - 의존 관계는 일시적인 관계
3. 상속관계
   - B 가 변경될때 A 도 변경된다.
4. 실체화 관계
   - 인터페이스 구현 관계

> 상속관계와 실체화 관계의 차이는, 상속은 구현이 바뀌어도 영향을 받을 수 있다. 실체화 관계는 인터페이스 시그니쳐가 바뀔때만 영향을 받는다.

### 패키지 의존성
- 패키지에 포함된 클래스 사이의 의존성
  - 어떤 패키지에 존재하는 클래스가 다른 패키지에 존재하는 클래스에 의존하는 경우를 말한다.

### 양방향 의존성을 피하라
- 좋은 의존성 관리를 위한 규칙

`양방향 의존성`
```java
class A {
    private B b;

    public void setA(B b) {
        this.b = b;
        this.b.setA(this);
    }
}

class B {
    private A a;

    public void setA(A a) {
        this.a = a;
    }
}
```

> 양방향 의존을 가질 경우 양쪽의 **싱크를 맞춰 주어야 한다.**
> 양방향 의존성을 피할수 있다면 단방향 연관관계로 바꾸어야 한다.

### 다중성이 적은 방향을 선택하라
OneTo-Many 보단, Many-To-One 관계를 선택하는것이 좋다.

`OnetoMany`
```java
class A {
    private Collection<B> bs;
}

class B {

}
```

`ManyToOne`
```java
class A {
    
}

class B {
    private A a;
}
```

> 컬렉션을 연관관계로 가지게 될경우 성능 이슈도 발생할 뿐더러 해당 의존관계를 유지하기 위한 비용이 크다.

### 의존성이 필요없다면 제거하라

### 패키지 사이의 의존성 사이클을 제거하라
- 양방향 의존성을 제거하는것이 좋다.
- 설계의 원칙은 무조건 **변경** 이다.

## 예제

`주문 플로우`
1. 가게 선택
2. 메뉴 선택
3. 장바구니 담기
4. 주문 완료

`도메인 컨셉 - 가게 와 메뉴`
```
메뉴
- 이름
- 설명

가게
- 이름
- 영업여부
- 최소주문금액
- 수수로율
- 수수료누적액

옵션
- 이름
- 가격

옵션 그룹
- 이름
- 베타선택여부
- 기본옵션여부
```  

`도메인 컨셉 - 주문`
```
주문
- 주문시간
- 상태

주문 항목
- 이름
- 갯수

주문 옵션
- 이름
- 가격

주문 옵션 그룹
- 이름
```

- 사용자가 장바구니에 담아 두었던 메뉴와, 업소가 메뉴를 변경하였을때 불일치 하는 경우가 발생한다.
> 주문이 발생할때 마다 주문 데이터와 업소 메뉴가 일치하는지 검증을 해야한다.

### 주문 벨리데이션
1. 메뉴 명과 주문 항목의 이름 비교
2. 옵션 그룹 명과 주문 옵션 그룹 명 비교
3. 옵션 명과 주문 옵션 명 비교
4. 옵션 가격과 주문 옵션 가격 비교
5. 가게의 영업중인지 확인
6. 주문금액이 최소주문금액 이상인지 비교

### 협력 설계하기
1. 주문하기 메시지 송신 (벨리데이션 시작)
2. 가게가 영업중인가 ?, 주문금액이 최소주문 금액 이상인가 ? (주문 -> 가게)
3. 메뉴 명과 주문항목 명 검증 (가게 -> 메뉴)
4. 옵션그룹 명과 주문 옵션 그룹 명 검증 (메뉴 -> 옵션 그룹)
5. 옵션 명과 옵션 가격 검증 (옵션 그룹 -> 옵션)
6. 모두 통과할 경우 주문에 성공한다.

> 동적인 구조로 설계를 했지만, 정적인 구조(코드) 로 만들어야한다. 
> 관계에는 방향이 필요하다. (실제 코드에 그려주어야 한다.)

관계의 방향 
    = 협력의 방향
    = 의존성의 방향

### 관계의 종류 결정
- 연관관계: 협력을 위해 영구적인 탐색구조
  - 객체간의 협력이 빈번하다.
- 의존관계: 협력을 위해 일시적으로 필요한 의존성
  - 파라미터, 리턴타입, 지역변수 등...

### 연관관계 = 탐색가능성
Order -> OrderLineItem
> Order 를 알면, Order 를 통해 OrderLineItem
> 연관관계란, 어떤 객체가 있는데 이 객체를 알면 다른 객체를 찾아갈 수 있다.

- 두 객체사이에 협력이 필요하고, 두 객체의 관계가 **영구적** 이라면, 연관관계를 사용한다.
- 일반적으로 **객체 참조 (구현방법)** 를 사용해 연관관계(개념) 를 구현한다.

> 개념과, 구현방법을 1:1로 매핑해선 안된다. 구현방법은 다양할 수 있다.

```java
class Order {
    private List<OrderLineItem> orderLineItems;

    public void place() {
        validate();
        ordered();
    }

    private void validate() {
        ...
        for (OrderLineItem orderLineItem: orderLineItems) {
            orderLineItem.validate();
        }
    }

    private void ordered() {

    }
}
```

- 메시지를 결정하고, 메소드를 만들어야 한다.


