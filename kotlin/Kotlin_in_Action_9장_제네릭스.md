# Kotlin in Action

## 9장 제네릭스
- 실체화한 타입 파라미터를 사용하면, 런타임 시점에 이를 활용할 수 있다.
    - 일반 클래스나 함수는 실행 시점에 타입 정보가 사라진다.
- 선언 지점 변성을 사용할 경우 기저 타입은 동일하지만, 타입 인자가 다른 두 제네릭 타입의 상위/하위 타입 관계에 따라
- 상위/하위 타입 관계가 어떻게 되는지 지정이 가능해진다.

`기저 타입`
- List 와 List<String> 이 기반 - 파생 타입 관계라고 보기 어렵기 때문에, 제네릭 타입에서는 타입 파라미터를 제외한 부분을 기저 타입이라는 용어로 사용한다.
- 위 의 경우 List 가 기저 타입이다.

#### 제네릭 타입 파라미터
- 제네릭스를 사용하면 **타입 파라미터 (type parameter)** 를 받는 타입을 정의할 수 있다.
- 제네릭 타입의 인스턴스를 생성하려면, 타입 파라미터를 구체적인 **타입 인자 (type argument)**로 치환해야 한다.
- 코틀린 컴파일러는 일반 타입과 마찬가지로 타입 인자도 추론이 가능하다.
    - 아래 코드에서 listOf 함수에 전달된 값이 문자열 이기 때문에 컴파일러는 List<String> 임을 추론한다.
```kotlin
val authors = listOf("Dmitry", "Sveltlana")
```

> 코틀린에서는 제네릭 타입 인자를 명시 하거나 컴파일러가 추론할 수 있어야한다.
> 자바는 뒤늦게 추가되어 이전 버전 호환성을 위해 제네릭이 없는 로(raw) 타입을 허용한다.

#### 제네릭 함수와 프로퍼티
- 제네릭 함수를 선언하면 특정 타입 뿐 아닌 모든 타입을 다루는 함수를 선언할 수 있다.
- 제네릭 함수를 호출 할 때는 반드시 구체적인 타입 인자를 넘겨 주어야한다.
```kotlin
fun <T> List<T>.slice(indices: IntRange) : List<T>
```
> 함수 타입 파라미터 T는 수신 객체와 반환 타입에 사용 된다.

`제네릭 함수`
```kotlin
/**
 * 제네릭 함수를 호출 할때 구체적인 타입 파라미터를 넘겨주어야 한다.
 * 하지만 대부분의 경우 컴파일러가 타입 파라미터를 추론할 수 있기 때문에 생략이 가능하다.
 */
fun main() {
    val letters = ('a'..'z').toList()
    println(letters.slice<Char>(0..2))
    println(letters.slice(0..2))
}
```

`제네릭 확장 프로퍼티`
```kotlin
/**
 * 제네릭 함수와 마찬가지로 제네릭 확장 프로퍼티도 정의가 가능하다.
 * 아래 함수는 리스트의 마지막 원소 바로 앞에 있는 원소를 반환하는 확장 함수이다.
 */
val <T> List<T>.penultimate: T
    get() = this[size - 2]

fun main() {
    println(listOf(1, 2, 3, 4).penultimate)
}
```

> 확장 프로퍼티에만 제네릭 타입 파라미터를 사용할 수 있다.

#### 제네릭 클래스 선언
- 자바와 마찬가지로 타입 파라미터를 넣은 클래스를 선언할 수 있다.
- 타입 파라미터를 클래스 명 뒤에 선언하면, 클래스 본문 내에서 해당 타입 파라미터를 사용할 수 있다.
```kotlin
/**
 * 코틀린에서도 제네릭 클래스를 선언할 수 있다.
 */
interface List<T> {
    operator fun get(index: Int): T
}
```

- 제네릭 클래스를 확장하는 클래스를 정의하면, 기반 타입의 제네릭 파라미터에 대해 타입 인자를 지정해 주어야 한다.
```kotlin
/**
 * 제네릭 클래스를 확장하는 경우, 구체적인 타입 인자를 넘겨주거나, 확장 클래스의 타입 인자를 사용할 수 있다.
 */
class StringList: GenericList<String> {
    override fun get(index: Int): String { return "1" }
}
```

> 타입 인자를 지정할 때 자기 자신 타입을 인자로 참조할 수 있다.
> Comparable<T> 인터페이스를 구현할 때가 대표적인 예이다.

#### 타입 파라미터 제약
- **타입 파라미터 제약 (type parameter constraint)** 은 클래스 혹은 함수에 사용 가능한 타입 인자를 제한하는 기능
- 어떤 타입을 제네릭 타입의 파라미터에 대한 **상한 (upper bound)** 로 지정하면 해당 제네릭 타입 을 인스턴스화 할때 타입 인자는 
반드시 상한 타입 이거나, 하위 타입이여야 한다.
- 제약을 가하려면 타입 파라메터 명 뒤에 **콜론 (:)** 을 사용해서 상한 타입을 명시하면 된다.
- 아래 코드는 자바에서 <T extends Number> T sum(List<T> list) 와 동일하다.
```kotlin
/**
 * 타입 파라미터 제약을 가하려면 파라미터 명 뒤에 콜론 (:) 을 표시하고 그 뒤에 상한 타입을 지정하면 된다.
 */
fun <T : Number> List<T>.sum() : T = get(0)
```