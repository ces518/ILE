# 코틀린을 다루는 기술

## 2장 코틀린 프로그래밍의 개요

### 필드와 변수
```kotlin
val name: String = "ncucu"
```

- 코틀린에서 변수의 선언 및 초기화는 위와 같은 구문으로 행해진다.
- val 키워드를 사용하는데 이는 **불변 (자바의 final)** 을 의미한다.
- 문장의 마지막에 세미콜론을 사용하지 않는다.

#### 타입 생략
```kotlin
val name = "ncucu"
```
- 코틀린에서는 **타입 추론 (type reference)** 을 제공한다.
    - 필드를 초기화 하는 값을 보고 변수의 타입을 컴파일러가 추론한다.
- 타입 추론이 제대로 동작하는 경우도 존재하므로 그럴 경우에는 타입을 반드시 명시해야 한다.

#### 가변 필드
- val 은 코틀린에서 불변을 의미한다.
- 모든 참조가 항상 불변은 아니지만, 가능하다면 최대한 val 을 지향해야 한다.
- 가변 참조를 원하다면 val 을 var 로 변경해서 사용해야 한다.

```kotlin
var name = "ncucu"
name = "ncucu2"
```

> 코틀린은 일반적으로 초기화하지 않은 참조를 사용하지 못하도록 만든다.
> 이부분은 초기화 하지 않은 참조를 null 로 설정하고 사용을 허용하는 자바와 다른점이다.

#### 지연 초기화
- 개발을 하다보면 한번 씩 지연 초기화가 필요한 시점이 있다.
- 초기화 비용이 너무 커서 사용하는 시점에 초기화를 한다거나, 특정 프레임워크의 기능사용 등이 그 이유이다.
- 일반적으로 변수를 var 로 선언하고 null 로 초기화해, 나중에 값을 대입하는 것이이다.
- 만약 한번 초기화 된 후에는 값이 바뀌는 일이 거의 없을 경우 불편함을 초례한다.
- 코틀린에서 **널이 될수 있는 타입** 과 **널이 될 수 없는 타입** 을 구분하고 있으며, 널을 허용하는 순간부터 불안한 코드가 된다.

```kotlin
var name: String? = null
...
name = getName()
```

- 만약 위와같은 코드가 싫다면, 초기화 되지 않음을 의미하는 문자열을 넣어두는 괴이한 (?) 방법을 사용해야 한다.

```kotlin
var name: String = "초기화_안됨"
...
name = getName()
``` 

- 위 코드도 썩 좋아보이는 방법은 아니다..
- 이런 문제를 해결하기 위해 코틀린에서는 지연 초기화 를 제공한다.

```kotlin
val name: String by lazy { getName() }

lateinit var name: String
...
name = getName()
```
- lateinit 은 지연 초기화 보다는 non-null 한 프로퍼티가 생성자 레벨에서 초기화 되지 않아도 컴파일러가 인정하도록 하는 방법이다.
- 단점은 항상 가변 (var) 이여야 한다는 점이다. (불변성 유지 X)
- by lazy 는 일종의 위임 프로퍼티 이다.
- 위임 프로퍼티를 사용함으로써 필드를 코드레벨이 아닌 외부 (데이터베이스 혹은 브라우저 세션, 맵 등) 에 저장할 수 있다.
- 또한 프로퍼티가 사용되는 최초 시점에 초기화를 실행한다.

> lateinit 은 DI 프레임워크를 사용하는 등의 경우를 제외하면 by lazy 와 비교했을때 장점이 없다..
> DI 를 사용하더라도 불변 프로퍼티를 사용할 수 있으므로, 가능한 한 생성자 기반 의존관계 주입을 사용하도록 노력해야 한다.

### 클래스와 인터페이스
- 코틀린 클래스는 자바와 상당히 다른 구문을 사용한다.

```kotlin
class Person constructor(name: String) {
    val name: String
    
    init {
        this.name = name
    }
}
```
- 이에 상응하는 자바코드는 다음과 같다.
```java
public final class Person {
    private final String name;
    
    public Person(String name) {
        this.name = name;
    }
    
    public String getName() {
        return name;
    }
}
```

- 코틀린 클래스의 특징 몇가지를 살펴보자.
1. 코틀린은 기본적으로 public 이다. 이를 생략할 수 있으며, private, protected, internal 변경자를 제공한다.
    - internal 은 자바의 default 접근제어자 에 상응한다.
    - protected 는 자바와 다르게 클래스를 확장하는 경우에만 사용이 가능하며, 다른 클래스에서는 protected 클래스에 접근할 수 없다.
2. 코틀린은 기본적으로 final 이다. 즉 상속이 불가능 하며 자바의 final 클래스와 동일하다.
    - 코틀린에서 상속을 허용하면 open 변경자를 사용해야 한다.
3. 생상자 정의가 클래스명 뒤에 존재한다. 생성자 내부구현은 init 블록 내에서 이루어진다.
4. 접근자가 필요없다. 컴파일 시점에 접근자를 생성해준다.
5. 자바와 달리 클래스명과 파일명이 일치하지 않아도 된다. 또한 한 파일내에 여러클래스 정의도 가능하다.

#### 간결한 클래스 선언
- 앞서 살펴본 예제를 좀 더 간결하게 선언하는 방법들이 몇가지 있다.

```kotlin
class Person constructor(name: String) {
    val name: String = name
}
```

```kotlin
class Person constructor(val name: String) {

}
```

```kotlin
class Person(val name: String)
```

- 자바와 비교했을때 간결함의 차이가 보이는가 ?
- 코틀린을 사용하면 보일러플레이트를 대부분 없앨 수 있어 간결한 코드를 만들 수 있다.

#### 상속
- 코틀린에서 인터페이스 혹은 다른 클래스를 상속받고 싶다면 다음과 같은 구문을 사용한다.
```kotlin
open class Person(val name: String, val registered: Boolean)

class Member(name: String, registered: Boolean): Person(name, registered)
``` 
- 코틀린의 클래스는 기본적으로 final 이기 떄문에 open 변경자를 통해 상속을 허용한다.
- 이는 확장을 염두해두고 설계하는 것임을 의미하고, 확장을 염두한 클래스만이 확장을 허용하는 것이 좋은 프로그래밍 습관이다.

#### 클래스 인스턴스화 하기
- 클래스를 인스턴스화 할때에도 코틀린에서는 좀 더 간결한 구문을 제공한다.

```kotlin
val person = Person("Bob", true)
```

```java
final Person person = new Person("Bob", true)
```

#### 프로퍼티 생성자 오버로드
- 필수가 아닌 프로퍼티에 기본값이 있는 경우 자바에서는 두가지 생성자를 사용해야 한다.
- 코틀린에서는 인자에 기본 값을 줌으로써 같은 효과를 얻을 수 있다.

```kotlin
class Person(val name: String, val registered: Boolean = false)
```

> 코틀린도 자바와 동일하게 생성자를 정의하지 않을 경우 기본생성자가 자동으로 만들어진다.

#### 비공개 생성자와 프로퍼티
- 코틀린에서도 생성자를 비공개로 만들경우 외부에서 생성자에서 접근할 수 없다.

```kotlin
class Person private constructor(val name: String)
```

#### 접근자와 프로퍼티
- 자바에서는 프로퍼티를 직접 노출하는것 보다 getter, setter 메소드를 통해 외부에 노출하는데 이 둘을 합쳐 **접근자 (accessor)** 라고 한다.
- 코틀린에서는 프로퍼티에 직접 접근하는것 처럼 보이지만, 실제로는 컴파일러가 생성한 게터를 사용한다.

```kotlin
val person = Person("Bob")
person.name
```

#### equals 와 hashCode 메소드
- 자바에서는 equals 와 hashCode 를 직접 구현하거나 IDE 혹은 Lombok 을 사용해 구현해야한다.
- 코틀린에서는 data class 를사용하면 컴파일러가 equals 와 hashCode 를 구현해준다. 
- 또한 toString, copy 함수등 편리한 함수들을 자동생성 해준다.

#### 데이터 객체 구조 분해
- 프로퍼티가 N 개 존재하는 데이터 클래스에는 component1 ~ componentN 이라는 함수가 자동으로 정의 된다.
- 이 함수들은 클래스에 프로퍼티가 정의된 순서대로 각 프로퍼티에 접근하며, 이런 함수는 객체의 **구조 분해 (destructing)** 에 사용된다.

```kotlin
data class Person(val name: String, val registered: Boolean = false)
fun show(persons: List<Person>) {
    for ((name, registered) in persons) {
        println("name = $name, registered = $registered")
    }
}
fun main(args: Array<String>) {
    val persons = listOf(Person("ncucu"), Person("ncucu2"))
    show(persons)
}
``` 
> 구조 분해를 통해 프로퍼티가 필요할 때마다 번거롭게 프로퍼티를 역참조할 필요가 없다.

#### 정적 메소드 구현
- 코틀린 클래스에는 정적 멤버가 없는 대신 **동반 객체 (companion object)** 를 사용해 같은 효과를 얻을 수 있다.
- 호출시 자바 정적멤버를 호출하는 것과 같이 호출이 가능하다.
```kotlin
data class Person(val name: String, val registered: Boolean = false) {
    companion object {
        fun create(xml: String): Person {
            // ....
        }
    }
}

Person.create(xmlString)
```
> 동반 객체의 멤버를 자바에서 호출하려면 동반 객체를 지정해서 호출해야 한다.
> 또한 동반 객체가 들어있는 외부 클래스의 정적 멤버로 이 함수를 호출하고 싶다면 @JvmStatic 애노테이션을 사용해야 한다.

#### 싱글턴
- 어떤 클래스의 객체를 단 하나만 만들어야 할 때가 있는데 이런 인스턴스는 **싱글턴 (singleton)** 이라고 한다.
- 자바에서는 싱글턴에 대한 논란이 많지만 코틀린에서는 object 라는 키워드로 클래스를 선언하기만 하면 쉽게 싱글턴을 만들 수 있다.
```kotlin
object CustomWindowAdapter: WindowAdapter() {
    override fun windowCloased(e: WindowEvent?) { ... }
}
```

> 싱글턴 객체에는 생성자가 있을 수 없으며, 프로퍼티가 존재한다면 반드시 초기화 해야한다.

#### 유틸 클래스 인스턴스화 방지
- 자바에서는 정적 메소드만을 가지는 유틸 클래스를 만들어 사용하는 경우가 자주 있다.
- 코틀린에서는 클래스 밖의 패키지 레벨에서 함수를 만들어 사용하면 된다.