# 코틀린을 다루는 기술

## 2장 코틀린 프로그래밍의 개요

### 필드와 변수
```kotlin
val name: String = "ncucu"
```

- 코틀린에서 변수의 선언 및 초기화는 위와 같은 구문으로 행해진다.
- val 키워드를 사용하는데 이는 **불변 (자바의 final)** 을 의미한다.
- 문장의 마지막에 세미콜론을 사용하지 않는다.

#### 타입 생략
```kotlin
val name = "ncucu"
```
- 코틀린에서는 **타입 추론 (type reference)** 을 제공한다.
    - 필드를 초기화 하는 값을 보고 변수의 타입을 컴파일러가 추론한다.
- 타입 추론이 제대로 동작하는 경우도 존재하므로 그럴 경우에는 타입을 반드시 명시해야 한다.

#### 가변 필드
- val 은 코틀린에서 불변을 의미한다.
- 모든 참조가 항상 불변은 아니지만, 가능하다면 최대한 val 을 지향해야 한다.
- 가변 참조를 원하다면 val 을 var 로 변경해서 사용해야 한다.

```kotlin
var name = "ncucu"
name = "ncucu2"
```

> 코틀린은 일반적으로 초기화하지 않은 참조를 사용하지 못하도록 만든다.
> 이부분은 초기화 하지 않은 참조를 null 로 설정하고 사용을 허용하는 자바와 다른점이다.

#### 지연 초기화
- 개발을 하다보면 한번 씩 지연 초기화가 필요한 시점이 있다.
- 초기화 비용이 너무 커서 사용하는 시점에 초기화를 한다거나, 특정 프레임워크의 기능사용 등이 그 이유이다.
- 일반적으로 변수를 var 로 선언하고 null 로 초기화해, 나중에 값을 대입하는 것이이다.
- 만약 한번 초기화 된 후에는 값이 바뀌는 일이 거의 없을 경우 불편함을 초례한다.
- 코틀린에서 **널이 될수 있는 타입** 과 **널이 될 수 없는 타입** 을 구분하고 있으며, 널을 허용하는 순간부터 불안한 코드가 된다.

```kotlin
var name: String? = null
...
name = getName()
```

- 만약 위와같은 코드가 싫다면, 초기화 되지 않음을 의미하는 문자열을 넣어두는 괴이한 (?) 방법을 사용해야 한다.

```kotlin
var name: String = "초기화_안됨"
...
name = getName()
``` 

- 위 코드도 썩 좋아보이는 방법은 아니다..
- 이런 문제를 해결하기 위해 코틀린에서는 지연 초기화 를 제공한다.

```kotlin
val name: String by lazy { getName() }

lateinit var name: String
...
name = getName()
```
- lateinit 은 지연 초기화 보다는 non-null 한 프로퍼티가 생성자 레벨에서 초기화 되지 않아도 컴파일러가 인정하도록 하는 방법이다.
- 단점은 항상 가변 (var) 이여야 한다는 점이다. (불변성 유지 X)
- by lazy 는 일종의 위임 프로퍼티 이다.
- 위임 프로퍼티를 사용함으로써 필드를 코드레벨이 아닌 외부 (데이터베이스 혹은 브라우저 세션, 맵 등) 에 저장할 수 있다.
- 또한 프로퍼티가 사용되는 최초 시점에 초기화를 실행한다.

> lateinit 은 DI 프레임워크를 사용하는 등의 경우를 제외하면 by lazy 와 비교했을때 장점이 없다..
> DI 를 사용하더라도 불변 프로퍼티를 사용할 수 있으므로, 가능한 한 생성자 기반 의존관계 주입을 사용하도록 노력해야 한다.

### 클래스와 인터페이스
- 코틀린 클래스는 자바와 상당히 다른 구문을 사용한다.

```kotlin
class Person constructor(name: String) {
    val name: String
    
    init {
        this.name = name
    }
}
```
- 이에 상응하는 자바코드는 다음과 같다.
```java
public final class Person {
    private final String name;
    
    public Person(String name) {
        this.name = name;
    }
    
    public String getName() {
        return name;
    }
}
```

- 코틀린 클래스의 특징 몇가지를 살펴보자.
1. 코틀린은 기본적으로 public 이다. 이를 생략할 수 있으며, private, protected, internal 변경자를 제공한다.
    - internal 은 자바의 default 접근제어자 에 상응한다.
    - protected 는 자바와 다르게 클래스를 확장하는 경우에만 사용이 가능하며, 다른 클래스에서는 protected 클래스에 접근할 수 없다.
2. 코틀린은 기본적으로 final 이다. 즉 상속이 불가능 하며 자바의 final 클래스와 동일하다.
    - 코틀린에서 상속을 허용하면 open 변경자를 사용해야 한다.
3. 생상자 정의가 클래스명 뒤에 존재한다. 생성자 내부구현은 init 블록 내에서 이루어진다.
4. 접근자가 필요없다. 컴파일 시점에 접근자를 생성해준다.
5. 자바와 달리 클래스명과 파일명이 일치하지 않아도 된다. 또한 한 파일내에 여러클래스 정의도 가능하다.

#### 간결한 클래스 선언
- 앞서 살펴본 예제를 좀 더 간결하게 선언하는 방법들이 몇가지 있다.

```kotlin
class Person constructor(name: String) {
    val name: String = name
}
```

```kotlin
class Person constructor(val name: String) {

}
```

```kotlin
class Person(val name: String)
```

- 자바와 비교했을때 간결함의 차이가 보이는가 ?
- 코틀린을 사용하면 보일러플레이트를 대부분 없앨 수 있어 간결한 코드를 만들 수 있다.

#### 상속
- 코틀린에서 인터페이스 혹은 다른 클래스를 상속받고 싶다면 다음과 같은 구문을 사용한다.
```kotlin
open class Person(val name: String, val registered: Boolean)

class Member(name: String, registered: Boolean): Person(name, registered)
``` 
- 코틀린의 클래스는 기본적으로 final 이기 떄문에 open 변경자를 통해 상속을 허용한다.
- 이는 확장을 염두해두고 설계하는 것임을 의미하고, 확장을 염두한 클래스만이 확장을 허용하는 것이 좋은 프로그래밍 습관이다.

#### 클래스 인스턴스화 하기
- 클래스를 인스턴스화 할때에도 코틀린에서는 좀 더 간결한 구문을 제공한다.

```kotlin
val person = Person("Bob", true)
```

```java
final Person person = new Person("Bob", true)
```