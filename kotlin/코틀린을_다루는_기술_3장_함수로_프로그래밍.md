# 코틀린을 다루는 기술

## 3장 함수로 프로그래밍
- 안전한 프로그래을 위해선 입력 데이터에 의존 하지 않는 부분과 외부 세계의 상태에 의존하는 부분으로 명확히 분리해야 한다.
    - 이는 부수효과 (side effect)를 제거하는 것만이아닌 **참조 투명성** 을 지키는것이다.
- 이런 함수를 **순수 함수 (pure function)** 라고 한다.
- 안전한 프로그램을 위해선 계산시 순수 함수만 사용하거나 계산 결과를 외부 세계에서 사용하려면 순수 효과만 사용해야 한다.
- 순수함수를 사용하지 않으면 프로그램은 **비결정적** 이기 때문에 올바른지 검증할 수 없다.
- 순수하지 않은 효과는 효과에 계산이 포함되기 때문에 테스트하기가 쉽지 않다.
- 순수함수는 테스트하기 쉽지만, 순수 효과는 테스트하기 어렵다.
- 함수형 프로그래밍은 효과를 다른 방식으로 바꾸는 프로그래밍 패러다임이다.
- 함수형 프로그밍은 효과를 적용하지 않고, 효과를 표현하는 데이터를 반환하는 함수를 사용한다.

### 함수란 무엇인가
- **함수 (function)** 란 수학적인 개념이다.
- **소스의 집합 (정의역, domain)** 과 **타깃의 집합 (공역, domain)** 사이에 어떤 조건을 만족시키는 대응관계 이다.
- 정의역과 공역이 서로 다를 필요는 없으며 어떤 함수의 정의역과 공역이 같은 집합일 수도 있다.

#### 두 함수 집합 사이의 대응 관계
- 함수가 되기 위해서는 대응관계가 한 가지 조건을 만족해야 한다.
- 정의역에 있는 모든 원소는 자신에 대응하는 원소가 공역에 꼭 하나 있어야 한다. (0도, 2도 안된다.)
```
// 함수의 정의
f(x) = x + 1
```
- 위 함수는 각 정수와 자신의 다음 값을 대응 시킨다.
- 함수의 이름을 너무 맹신해서는 안된다. 단지 함수가 하는 일을 기억하기 좋게 이름을 붙일 수 있을 뿐이다.

> 함수가 어떤 **동작** 을 하는것이 아닌 **어떤 것인지 (정의)** 하고 있음을 유의 하라.

#### 코틀린 역함수
- 함수에는 **역 함수 (inverse function)** 가 있을수도 있고, 없을수도 있다.
- 함수 f(x) 가 A -> B 로 가는 함수라면 (A 는 정의역, B 는 공역) 역함수는 f-1(x) 이며, B 가 정의역, A 가 공역이 된다.
- f 함수의 타입이 A -> B 라면 역함수는 B -> A 이다.
- 역함수가 존재하지 않는 간단한 예제를 살펴보자.
```
f(x) = (2 * x)
```
- 위 함수는 역함수가 존재하지 않는다.
- x 가 홀수라면 함수의 값이 N 에 속하지 않기 떄문이다.

#### 부분함수 다루기
- 함수가 되려면 대응관계가 아래 두가지 조건을 만족해야 한다.
1. 정의역의 모든 원소에 대해 함수가 정의되어야 한다.
2. 정의역의 모든 원소는 반드시 공역의 한 값에만 대응해야 한다.
- 정의역의 모든 원소에 대해 정의되어 있지 않지만, 나머지 요구조건을 만족하는 대응 관계를 **부분 함수 (partical function)** 이라고 한다.
- 부분함수가 아닌 함수를 **전 함수 (total function)** 이라고 한다.

> 진짜 함수는 항상 전 함수 이며, 부분함수는 함수가 아니다.

#### 함수 합성
- 함수는 서로 합성해서 다른 함수를 만들어낼 수 있는 빌딩 블록이다.
- f 와 g 의 합성을 f ⚬ g 라고 쓰며, f 라운드 g 라고 읽는다.
```
f(x) = x * 2
g(x) = x + 1
// 위 두함수를 합성하면 아래와 같다.
f ⚬ g = f(g(x)) = f(x + 1) = (x + 1) * 2
```

#### 인자를 여럿 받는 함수
- 간단히 말하면, 인자가 여럿 있는 함수란 없다.
- 함수는 소스 집합과 타깃 집합 사이의 대응 관계이다.
- f(x, y) = x + y 는 마치 두개의 인자를 받는 함수처럼 보이지만, 실제로는 그렇지 않다.
- 이런 경우 **튜플 (tuple)** 이라는 개념의 특별한 경우이다. **쌍 (pair)** 은 원소가 두 개인 튜플이다.
```
f((3, 5)) = 3 + 5 = 8
```
- 튜플은 괄호를 둘러싸 표현한다.
- 이런 경우 중복된 괄호를 생략해 단순하게 쓰는것이 관행이다.
- f(3, 5) = 3 + 5 = 8

#### 커리한 함수
- 함수 f(x)(y) 는 f(x, y)의 커리한 형태 라고 한다.
- 튜플에 대한 함수에 대해 이런식으로 변환을 적용해서 함수를 반환하는 함수로 바꾸는 과정을 **커링 (currying)** 이라고 한다. 
```
f(x, y) = x + 5
f(x)(y) = g(y) = x + y
```

#### 부분 적용 함수
- 커리한 함수를 사용하면, 두 인자를 따로 분리해 적용할 수 있다.
```
f(rate, price) = price / 100 * (100 + rate)
// 위 함수를 커링한 버전
f(rate)(price)
g(price)(rate)
```
- f(rate) 혹은 g(rate) 같은 형태의 함수를 부분 적용 함수라고 한다.
- 함수 인자를 평가할 때 부분 적용 함수가 큰 역할을 한다.

#### 효과가 없는 함수
- 순수 함수는 외부 세계의 어떤 요소도 변이시키지 않고, 인자도 변이시키지 않으며, 오류가 발생해도 예외를 던지지 않는다.
- 하지만 순수 함수는 예외나 비슷한 어떤 값도 반환할 수 있다.

### 코틀린 함수
- 코틀린에서는 메소드를 함수라 부른다.
- 이런 함수에는 두 가지 문제가 있다.
- 데이터와 함수는 근본적으로 동일하며, 어떤 데이터든 실제로는 함수라 할 수 있고, 어떤 함수든 실제로는 데이터라 할 수 있다.

#### 함수를 데이터로 이해
- 함수는 데이터와 비슷하다. 다른 데이터와 마찬가지로 함수도 타입이 존재한다.
- 함수를 다른 함수의 인자로 넘길 수 있고, 함수가 함수를 반환할 수 있다.
- fun 으로 정의한 함수는 이런 방식으로는 저장할 수도 없지만, 코틀린에서 이런 메소드를 진짜 함수로 변환할 때 필요한 모든 메커니즘을 제공한다.

#### 데이터를 함수로 이해
- **함수** 는 어떤 정해진 조건을 만족해야하는 소스 집합과 타깃 집합 사이의 대응 관계 이다.
- 인자에 따라 반환 값이 달라지지 않는 함수를 **상수 함수 (constant function)** 이라고 한다.

#### 객체 생성자를 함수로 사용
- 코틀린은 객체를 생성할 때 함수 호출 구문을 사용한다.
- 코틀린에서는 클래스명 뒤에 괄호를 붙여 생성자 인자를 넣으면 인스턴스 객체를 얻을 수 있다.
- 코틀린 생성자는 순수함수인가 ? -> 정의한 equals 함수에 따라 동등성이 달라진다.

#### 코틀린 fun 함수 사용
- fun 키워드를 사용해 정의한 함수는 선언 방식과 관계없이 **진짜 함수임을 보장할 수 없다.**
- 함수나 메소드가 순수 함수가 되기 위한 조건
1. 외부의 어떤 것도 변이 시켜서는 안된다. 내부에서 상태를 변이시킨다면, 외부에서 관찰할 수 없어야 한다.
2. 인자를 변이시켜서는 안된다.
3. 예외나 오류를 던져서는 안된다.
4. 항상 값을 반환해야 한다.
5. 인자가 같다면 항상 같은 결과를 내놓아야 한다.

#### 순수 함수와 순수하지 않은 함수
```kotlin
fun add(a: Int, b: Int): Int = a + b
fun div(a: Int, b: Int): Int = a / b
```
- add 함수는 항상 인자에 따라 정해지는 값을 반환하기 때문에 순수함수이다.
- div 함수는 두번째 파라미터가 0 일 경우 예외를 발생시킨다. 따라서 순수함수로 만들려면 0일 경우 오류를 의미하는 값을 반환해야 한다.

#### 함수 값 사용
- 함수를 데이터처럼 다룰 수 있지만, fun 으로 정의된 함수는 그렇지 않다
- 하지만 코틀린은 함수를 데이터처럼 다룰 수 있게 한다.
```kotlin
fun double(x: Int) = x * 2
val double: (Int) -> Int = { x -> x * 2}
```

#### 코틀린의 함수 종류
- 함수가 값이라면 굳이 fun 을 사용한 함수를 정의해야 하는 이유가 있을까 ?
- fun 으로 정의한 함수는 실제 함수가 아니다. 이는 메소드, 프로시저 등으로 불린다.
- fun 으로 정읳나 함수로 순수 함수를 표현할 수는 있지만, 데이터처럼 취급할 수는 없다.
- 그럼에도 fun 함수를 사용하는 이유는, fun 함수가 더 효율적이기 때문이다. (최적화)
- 인자를 넘기고, 그 인자에 따른 반환 값을 얻는 일만 하는 경우, fun 으로 정의한 함수를 사용하라.
- 함수를 데이터 처럼 취급해야 하거나, 함수에서 함수를 반환해야 하는 경우, 변수 등에 함수를 저장해야 한다면 함수 타입의 식을 사용하라.

