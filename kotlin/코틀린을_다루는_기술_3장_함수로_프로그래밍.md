# 코틀린을 다루는 기술

## 3장 함수로 프로그래밍
- 안전한 프로그래을 위해선 입력 데이터에 의존 하지 않는 부분과 외부 세계의 상태에 의존하는 부분으로 명확히 분리해야 한다.
    - 이는 부수효과 (side effect)를 제거하는 것만이아닌 **참조 투명성** 을 지키는것이다.
- 이런 함수를 **순수 함수 (pure function)** 라고 한다.
- 안전한 프로그램을 위해선 계산시 순수 함수만 사용하거나 계산 결과를 외부 세계에서 사용하려면 순수 효과만 사용해야 한다.
- 순수함수를 사용하지 않으면 프로그램은 **비결정적** 이기 때문에 올바른지 검증할 수 없다.
- 순수하지 않은 효과는 효과에 계산이 포함되기 때문에 테스트하기가 쉽지 않다.
- 순수함수는 테스트하기 쉽지만, 순수 효과는 테스트하기 어렵다.
- 함수형 프로그래밍은 효과를 다른 방식으로 바꾸는 프로그래밍 패러다임이다.
- 함수형 프로그밍은 효과를 적용하지 않고, 효과를 표현하는 데이터를 반환하는 함수를 사용한다.

### 함수란 무엇인가
- **함수 (function)** 란 수학적인 개념이다.
- **소스의 집합 (정의역, domain)** 과 **타깃의 집합 (공역, domain)** 사이에 어떤 조건을 만족시키는 대응관계 이다.
- 정의역과 공역이 서로 다를 필요는 없으며 어떤 함수의 정의역과 공역이 같은 집합일 수도 있다.

#### 두 함수 집합 사이의 대응 관계
- 함수가 되기 위해서는 대응관계가 한 가지 조건을 만족해야 한다.
- 정의역에 있는 모든 원소는 자신에 대응하는 원소가 공역에 꼭 하나 있어야 한다. (0도, 2도 안된다.)
```
// 함수의 정의
f(x) = x + 1
```
- 위 함수는 각 정수와 자신의 다음 값을 대응 시킨다.
- 함수의 이름을 너무 맹신해서는 안된다. 단지 함수가 하는 일을 기억하기 좋게 이름을 붙일 수 있을 뿐이다.

> 함수가 어떤 **동작** 을 하는것이 아닌 **어떤 것인지 (정의)** 하고 있음을 유의 하라.

#### 코틀린 역함수
- 함수에는 **역 함수 (inverse function)** 가 있을수도 있고, 없을수도 있다.
- 함수 f(x) 가 A -> B 로 가는 함수라면 (A 는 정의역, B 는 공역) 역함수는 f-1(x) 이며, B 가 정의역, A 가 공역이 된다.
- f 함수의 타입이 A -> B 라면 역함수는 B -> A 이다.
- 역함수가 존재하지 않는 간단한 예제를 살펴보자.
```
f(x) = (2 * x)
```
- 위 함수는 역함수가 존재하지 않는다.
- x 가 홀수라면 함수의 값이 N 에 속하지 않기 떄문이다.

#### 부분함수 다루기
- 함수가 되려면 대응관계가 아래 두가지 조건을 만족해야 한다.
1. 정의역의 모든 원소에 대해 함수가 정의되어야 한다.
2. 정의역의 모든 원소는 반드시 공역의 한 값에만 대응해야 한다.
- 정의역의 모든 원소에 대해 정의되어 있지 않지만, 나머지 요구조건을 만족하는 대응 관계를 **부분 함수 (partical function)** 이라고 한다.
- 부분함수가 아닌 함수를 **전 함수 (total function)** 이라고 한다.

> 진짜 함수는 항상 전 함수 이며, 부분함수는 함수가 아니다.

#### 함수 합성
- 함수는 서로 합성해서 다른 함수를 만들어낼 수 있는 빌딩 블록이다.
- f 와 g 의 합성을 f ⚬ g 라고 쓰며, f 라운드 g 라고 읽는다.
```
f(x) = x * 2
g(x) = x + 1
// 위 두함수를 합성하면 아래와 같다.
f ⚬ g = f(g(x)) = f(x + 1) = (x + 1) * 2
```

#### 인자를 여럿 받는 함수
- 간단히 말하면, 인자가 여럿 있는 함수란 없다.
- 함수는 소스 집합과 타깃 집합 사이의 대응 관계이다.
- f(x, y) = x + y 는 마치 두개의 인자를 받는 함수처럼 보이지만, 실제로는 그렇지 않다.
- 이런 경우 **튜플 (tuple)** 이라는 개념의 특별한 경우이다. **쌍 (pair)** 은 원소가 두 개인 튜플이다.
```
f((3, 5)) = 3 + 5 = 8
```
- 튜플은 괄호를 둘러싸 표현한다.
- 이런 경우 중복된 괄호를 생략해 단순하게 쓰는것이 관행이다.
- f(3, 5) = 3 + 5 = 8

#### 커리한 함수
- 함수 f(x)(y) 는 f(x, y)의 커리한 형태 라고 한다.
- 튜플에 대한 함수에 대해 이런식으로 변환을 적용해서 함수를 반환하는 함수로 바꾸는 과정을 **커링 (currying)** 이라고 한다. 
```
f(x, y) = x + 5
f(x)(y) = g(y) = x + y
```

#### 부분 적용 함수
- 커리한 함수를 사용하면, 두 인자를 따로 분리해 적용할 수 있다.
```
f(rate, price) = price / 100 * (100 + rate)
// 위 함수를 커링한 버전
f(rate)(price)
g(price)(rate)
```
- f(rate) 혹은 g(rate) 같은 형태의 함수를 부분 적용 함수라고 한다.
- 함수 인자를 평가할 때 부분 적용 함수가 큰 역할을 한다.

#### 효과가 없는 함수
- 순수 함수는 외부 세계의 어떤 요소도 변이시키지 않고, 인자도 변이시키지 않으며, 오류가 발생해도 예외를 던지지 않는다.
- 하지만 순수 함수는 예외나 비슷한 어떤 값도 반환할 수 있다.

### 코틀린 함수
- 코틀린에서는 메소드를 함수라 부른다.
- 이런 함수에는 두 가지 문제가 있다.
- 데이터와 함수는 근본적으로 동일하며, 어떤 데이터든 실제로는 함수라 할 수 있고, 어떤 함수든 실제로는 데이터라 할 수 있다.

#### 함수를 데이터로 이해
- 함수는 데이터와 비슷하다. 다른 데이터와 마찬가지로 함수도 타입이 존재한다.
- 함수를 다른 함수의 인자로 넘길 수 있고, 함수가 함수를 반환할 수 있다.
- fun 으로 정의한 함수는 이런 방식으로는 저장할 수도 없지만, 코틀린에서 이런 메소드를 진짜 함수로 변환할 때 필요한 모든 메커니즘을 제공한다.

#### 데이터를 함수로 이해
- **함수** 는 어떤 정해진 조건을 만족해야하는 소스 집합과 타깃 집합 사이의 대응 관계 이다.
- 인자에 따라 반환 값이 달라지지 않는 함수를 **상수 함수 (constant function)** 이라고 한다.

#### 객체 생성자를 함수로 사용
- 코틀린은 객체를 생성할 때 함수 호출 구문을 사용한다.
- 코틀린에서는 클래스명 뒤에 괄호를 붙여 생성자 인자를 넣으면 인스턴스 객체를 얻을 수 있다.
- 코틀린 생성자는 순수함수인가 ? -> 정의한 equals 함수에 따라 동등성이 달라진다.

#### 코틀린 fun 함수 사용
- fun 키워드를 사용해 정의한 함수는 선언 방식과 관계없이 **진짜 함수임을 보장할 수 없다.**
- 함수나 메소드가 순수 함수가 되기 위한 조건
1. 외부의 어떤 것도 변이 시켜서는 안된다. 내부에서 상태를 변이시킨다면, 외부에서 관찰할 수 없어야 한다.
2. 인자를 변이시켜서는 안된다.
3. 예외나 오류를 던져서는 안된다.
4. 항상 값을 반환해야 한다.
5. 인자가 같다면 항상 같은 결과를 내놓아야 한다.

#### 순수 함수와 순수하지 않은 함수
```kotlin
fun add(a: Int, b: Int): Int = a + b
fun div(a: Int, b: Int): Int = a / b
```
- add 함수는 항상 인자에 따라 정해지는 값을 반환하기 때문에 순수함수이다.
- div 함수는 두번째 파라미터가 0 일 경우 예외를 발생시킨다. 따라서 순수함수로 만들려면 0일 경우 오류를 의미하는 값을 반환해야 한다.

#### 함수 값 사용
- 함수를 데이터처럼 다룰 수 있지만, fun 으로 정의된 함수는 그렇지 않다
- 하지만 코틀린은 함수를 데이터처럼 다룰 수 있게 한다.
```kotlin
fun double(x: Int) = x * 2
val double: (Int) -> Int = { x -> x * 2}
```

#### 코틀린의 함수 종류
- 함수가 값이라면 굳이 fun 을 사용한 함수를 정의해야 하는 이유가 있을까 ?
- fun 으로 정의한 함수는 실제 함수가 아니다. 이는 메소드, 프로시저 등으로 불린다.
- fun 으로 정읳나 함수로 순수 함수를 표현할 수는 있지만, 데이터처럼 취급할 수는 없다.
- 그럼에도 fun 함수를 사용하는 이유는, fun 함수가 더 효율적이기 때문이다. (최적화)
- 인자를 넘기고, 그 인자에 따른 반환 값을 얻는 일만 하는 경우, fun 으로 정의한 함수를 사용하라.
- 함수를 데이터 처럼 취급해야 하거나, 함수에서 함수를 반환해야 하는 경우, 변수 등에 함수를 저장해야 한다면 함수 타입의 식을 사용하라.

#### 함수 참조
- 코틀린은 자바와 같은 방식으로 메소드 참조를 사용할 수 있다.
```kotlin
fun double(n: Int): Int = n * 2
val multiplyBy: (Int) -> Int = ::double
```
- 주의 할점은 만약 메소드 참조 앞에 클래스명을 붙인다면 위와는 다른 타입의 함수가 생긴다.
```kotlin
val multiplyBy: (MyClass, Int) -> Int = MyClass::double // { obj: MyClass, n: Int -> (obj::double)(n)
```

#### 함수 합성
- fun 함수는 다음과 같이 쉽게 합성할 수 있다.
- 하지만 이는 함수 합성이 아닌, 함수 적용을 합성한 것이다.
```kotlin
fun square(n: Int) = n * n
fun triple(n: Int) = n * 3
square(triple(2))
```

#### 위와 같은 형태의 함수 합성을 정의하기
```kotlin
fun compose(f: (Int) -> Int, g: (Int) -> Int): (Int) -> Int = { x -> f(g(x)) }

// 단순화
fun compose(f: (Int) -> Int, g: (Int) -> Int): (Int) -> Int = { f(g(it)) }

val squareOfTriple = compose(::square, ::triple)
squareOfTriple(2)
```

#### 함수 재사용
- 함수를 쉽게 재사용하려면, 타입 파라미터를 사용하는 **다형적 (polymorphic)** 함수로 만들어야 한다.
```kotlin
fun <T, U, V> compose(f: (U) -> V, g: (T) -> U): (T) -> V = { f(g(it)) }
```

### 고급함수 기능
- **다인자 (multi-argument)** 함수의 문제를 생각해보기

#### 인자가 여럿인 함수 처리
- 인자가 여럿있는 함수란 존재하지 않고, 단지 원소개 여러개 들어있는 튜플을 유일한 인자로 받는 함수만이 존재한다.
- 원소의 갯수가 적으면 갯수에 따라 *튜플 (tuple)** , **트리플렛 (triplet)** , **쿼텟 (quartet)** 등의 이름이 붙는다.

#### 두 Int 값을 더하는 함수 작성
- Int 를 인자로 받고, Int 에서 Int 로 가는 함수를 반환해야 한다.
- 이를 람다로 구현한다면 다음과 같다.
```kotlin
val add: (Int) -> (Int) -> Int = { a -> { b -> a + b } }
```
- **타입 별명 (type alias)** 를 사용한다면, 특정 타입을 별칭으로 사용할 수 있다.
```kotlin
typealias IntBinOp = (Int) -> (Int) -> Int
val add: IntBinOp = { a -> { b -> a + b } }
```

> 함수 인자의 개수에는 제한이 없으며, 원하는 만큼 많은 인자를 받는 함수를 정의할 수 있다.
> 위의 add 와 같은 형태로 정의한 함수를, **동등한 튜플을 인자로 받는 함수로부터 커리한 함수** 라고 한다.

#### 커리한 함수 적용
- 커리한 함수는 일반적인 다른 함수와 동일하게 적용할 수 있다.
- 첫번째 인자를 적용한 뒤 마지막 인자를 적용할때까지 반복 적용하면 된다.
- 위에서 정의한 add 함수에 3과 5를 적용한다면 다음과 같다.
```kotlin
add(3)(5)
``` 

#### 고차 함수 구현
- 함수를 인자로 받거나, 함수를 결과로 돌려주는 함수를 **고차 함수 (HOF, High-Order-Function)** 이라고 한다.
- 앞선 예제에서 보았던 square, triple 함수를 값으로 정의하고, 이 둘을 합성한 squareOfTriple 을 만들어 보자.
```kotlin
val compose: ((Int) -> Int) -> ((Int) -> Int) -> (Int) -> Int = { x -> { y -> { z -> x(y(z)) }}}
``` 

```kotlin
typealias IntUnaryOp = (Int) -> Int
val compose: (IntUnaryOp) -> (IntUnaryOp) -> IntUnaryOp = { x -> { y -> { z -> x(y(z)) }}}

val square: IntUnaryOp = { it * it }
val triple: IntUnaryOp = { it * 3 }

val squareOfTriple = compose(square)(triple)
squareOfTriple(2)
```

#### 다형적 HOF 정의
- 코틀린은 다향적 프로퍼티를 제공하지 않기 때문에 문제가 생긴다.
- 타입파라미터를 사옹하려면, 클래스, 인터페이스, fun 으로 정의한 함수에만 타입파라미터를 사용할 수 있다.
- 프로퍼티가 아닌 함수, 클래스, 인터페이스 중 하나에 정의할 함수를 저장해서 해결해야 한다.
```kotlin
fun <T, U, V> higherCompose(): ((U) -> V) -> ((T) -> U) -> (T) -> V =
    { f ->
        { g ->
            { x -> f(g(x)) }
        }
    }
val squareOfTriple = higherCompose<Int, Int, Int>()(square)(triple)
``` 

> 컴파일러는 T, U, V 타입을 추론할 수 없기 때문에, 타입 정보를 넘겨주어야 한다. Type Inference failed ... 예외가 발생한다.

#### 함수 파라미터 테스트
- 파라미터의 순서에 대해 의심이 간다면, 다른 타입의 함수를 사용해 테스트해 볼 수 있다.
```kotlin
fun testHigherCompose() {
    val f: (Double) -> Int = { a -> (a * 3).toInt() }
    val g: (Long) -> Double = { a -> a + 2.0 }
    
    assertEquals(Integer.valueOf(9), f(g(1L)))
    assertEquals(Integer.valueOf(9), higherCompose<Long, Double, Int>()(f)(g)(1L))
}
```

#### 익명함수
- 함수의 이름이 없는 함수를 **익명 함수 (anonymous function)** 이라고 한다.
- 다음은 익명 함수를 사용하는 예제이다.
```kotlin
val f: (Double) -> Double = { Math.PI / 2 - it }
val sin: (Double) -> Double = Math::sin
val cos: Double = compose(f, sin)(2.0)

// 익명함수 사용
val cosValue: Double = compose({ x: Double -> Math.PI / 2 - x }, Math::sin)(2.0)

// 고차함수 사용
val cos = (higherCompose<Double, Double, Double>()){ x: Double -> Math.PI / 2 - x }(Math::sin)
val cosVale = cos(2.0)
```
> 람다를 괄호 밖으로 빼낼 수 있다. 약간 이상해보이지만, 코틀린에서는 이런 형식을 권장한다.
> 또한 고차 함수에도 동일하게 익명함수를 사용할 수 있다.

#### 익명 함수를 사용하는경우, 이름이 있는 함수를 사용해야 하는 경우
- 익명함수를 사용할수 없는 경우를 제외하면, 어떤것을 사용할지 결정하는 것은 개발자의 선택에 달렸다.
- 일반적으로 한 번만 사용하느 함수는 익명 함수로 정의하라.
    - 이는 1번만 작성한다는 의미이며, 인스턴스화 횟수와 혼동하지 말아야 한다.
- 성능에 대해서는 걱정하지 말고 코드 명확성 / 유지 보수성을 고려해 결정해야 한다.
- 성능 또는 재사용성을 걱정한다면 함수 참조를 자주 사용하라.

#### 타입 추론 
- 익명함수를 사용할 때 타입추론이 문제가 될 수 있다.
- 위 예제에서는 컴파일러가 익명 함수의 타입을 추론할 수 있었지만, 타입추론이 항상 제대로 동작하는 것은 아니다.

#### 로컬함수 정의
- 함수내에서 함수 값 뿐만이 아닌, fun 함수도 선언할 수 있다.
```kotlin
fun cos(arg: Double): Double {
    fun f(x: Double): Double = Math.PI / 2 - x
    fun sin(x: Double): Double = Math.sin(x)
    return compose(::f, ::sin)(arg)
}
```

#### 클로저 구현
- 순수함수가 결과를 계산할 때 자신의 인자를 제외한 다른 어떤 것에도 영향을 받지 않아야 한다.
- 순수 함수는 **참조 투명성** 을 지키는 함수이다.
- 함수를 반환하는 것 외에 외부에서 관찰가능한 효과가 없어야 한다.
- 반환 값이 만약 자신의 인자뿐이 아닌, 자신을 둘러싼 영역의 요소에 의해 결정된다면 어떻게 될까
- 이런 경우에는 자신을 두러싸고 있는 영역의 요소를 함수가 사용하는 **암시적 파라미터** 라고 간주할 수 있다.

```kotlin
val taxRate = 0.09
fun addTax(price: Double) = price + price * taxRate
```
- 위 예제는 taxRate 변수에 대해 **닫혀 있다.**
- addTax 는 price 의 함수가 아니다.
    - 이유는 인자가 같아도 결과가 달라질 수 있다.
    - 이는 price, taxRate 튜플에 대한 함수로 볼 수 있다.
- 리팩터링 혹은 함수를 다른 함수에 넘길때 클로저는 문제가 될 수 있다.
- 이를 해결하기 위해서는 **더 모듈화** 해야 한다.
    - 각 부분이 서로 독립적인 모듈로 작용하도록 만들어야 한다.
    
```kotlin
val taxRate = 0.09
fun addTax(taxRate: Double, price: Double) = price + price * taxRate
```
- 위 예제 처럼 클로저 대신 튜플을 인자로 받는 함수로 정의하여 모듈화를 달성해야 한다.

`위 예제를 커리한 버전`
```kotlin
val taxRate = 0.09

val addTax = { taxRate: Double ->
                { price: Double ->
                    price + price * taxRate 
                }
            }
addTax(taxRate)(12.0)
```

> fun 함수를 커리한것은 의미가 없다. 반환하는 함수는 반드시 함수 값을 사용해야 한다.

#### 함수 부분 적용과 자동 커링
- 클로저와 커리한 함수는 같은 결과를 내놓기 때문에 동등한 것으로 보이지만, 의미상 다르다.
- 클로저를 사용한 함수는 바뀌지 않은 파라미터에 대해 닫혀 있다.
- 반면 커리한 버전은 함수 호출시마다 두 인자를 모두 바꿀 수 있다.

```kotlin
class TaxComputer(private val rate: Double) {
    fun compute(price: Double) = price * rate + price
}

// 클로저를 사용한 부분
val tc9 = TaxComputer(0.09)
tc9.compute(12.0)

// 커리한 함수 부분 적용
val tc9 = addTax(0.09)
val price = tc9(12.0)
```

- 커링은 튜플을 인자로 받는 함수를 한번에 하나씩 인자를 부분 적용 가능한 함수로 대츠하는 과정이다.
- 튜플을 받는 함수와 커리한 함수의 가장 큰 차이는 **부분 적용** 이다.
- 튜플을 받는 함수는 함수를 적용하기전 모든 인자에 대해 평가를 해야한다.
- 추상화는 프로그래밍의 핵심이다. 커링과 부분적용 함수를 자동으로 수행하기 위해 추상화 한다.
- 커리한 함수를 사용하면, 부분적용이 매우 단순해진다는 장점이 있다.

#### 연습문제 1
- 인자를 두개 받는 fun 함수를 작성
- 두번째 인자는 인자를 두개 받는 커리한 함수이다.
- 첫번째 인자는 두번째 인자의 첫번째 인자와 같은 타입이다.
- 해당 함수는 두번째 인자에 첫번째 인자를 적용한 결과를 반환한다.
```kotlin
fun <A, B, C> partialA(a: A, f: (A) -> (B) -> C): (B) -> C
```

#### 연습문제 2
- 인자를 두개 받는 fun 함수를 작성
- 두번째 인자는 인자를 두개 받는 커리한 함수이다.
- 첫번째 인자는 두번째 인자의 두번째 인자와 같은 타입이다.
- 해당 함수는 두번째 인자의 두번째 인자에 첫번째 인자를 적용한 결과를 반환한다.
```kotlin
fun <A, B, C> partialB(b: B, f: (A) -> (B) -> C): (A) -> C
```

#### 부분 적용 함수의 인자 바꾸기
- 커리한 함수의 인자 순서를 바꾼 새로운 함수를 반환하는 fun 함수
- 이 방법을 사용하면 인자의 수와 관계 없이 원하는 순서대로 인자 순서를 재배열 할 수 있다.
```kotlin
fun <T, U, V> swapArgs(f: (T) -> (U) -> V): (U) -> (T) -> (V) = 
    { u -> { t -> f(t)(u) }}
```

#### 항등 함수
- 연산을 함수에 적용하려면 연사에 상요할 중립적인 원소 (함수) 가 필요하다.
- **중립 연소 (neutral element)** 는 덧셈의 0 이나 곱셉의 1 과 같은 역할을 하는 원소를 의미한다.
- 함수 합성의 중립 원소는 인자를 그대로 돌려준다. 때문에 이를 **항등 (identity) 함수** 라고 한다.
- 정수 곱셉 혹은 문장려 연결 등에서는 **항등원 (identity element)** 라는 용어를 중립우너소 대신 사용한다.

`코틀린에서 정의하는 항등 함수`
```kotlin
val identity: (Int) -> Int = { it }
```

#### 올바른 타입 사용
- 너무 흔히 사용하는 타입을 사용하면 문제가 생길 수 있다.
- 이름 보다는 타입을 신뢰해야 한다.
- Double 을 price 라고 부른다고 해서 해당 값이 가격이 되는것은 아니다.
- 더 안전한 프로그램을 만들려면 강력한 타입을 사용해 컴파일러가 검사하게 만들어야 한다.

#### 값 타입
- **값 타입 (value type)** 은 값을 표현하는 타입을 의미 한다.
- 아래는 값타입을 정의하는 간단한 예제이다.
```kotlin
data class Price(val value: Double) {
    operator fun plus(price: Price) = Price(this.value + price.value)
}
data class Weight(val value: Double) {
    operator fun plus(weight: Weight) = Weight(this.value + weight.value)
}
```

#### fold 와 reduce
- 컬렉션을 하나로 졸여내는 과정을 fold 혹은 reduce 라고 한다.
- fold
    - 시작하는 원소를 제공
    - 결과 타입이 컬렉션의 원소 타입과 다름 
- reduce
    - 시작하는 원소를 제공하지 않음 
    - 결과 타입이 컬렉션의 원소 타입과 같음

> 컬렉션이 비어 있다면 reduce 는 아무런 결과를 내지 못하지만, fold 는 시작 원소를 결과로 내놓는다.

#### invoke 관례를 활용한 값타입 검증
- 만약 어떤 값타입 객체를 생성할때 검증이 필요하다면 invoke 관례를 활용해 다음과 같이 선언할 수 있다.
```kotlin
data class Price private constructor(private val value: Double) {
    companion object {
        val identity = Price(0.0)
        operator fun invoke(value: Double) = 
            if (value > 0) 
                Price(value)
            else
                throw IlelgalArgumentException()
    }
}
Price(1.0)
```

## 정리
- 함수는 소스 집합 (정의역) 과 타깃 집합(공역) 사이의 대응 관계이다.
- 순수 함수는 반환 값을 제외하면 아무런 효과도 관찰할 수 없는 함수를 말한다.
- 함수는 인자를 하나만 받을수 있으며, 여러원소로 이뤄진 튜플을 인자로 받을 수 있다.
- 인자가 튜플인 함수를 커리한 함수로 만들면 튜플의 각 원소를 한번에 하나씩 적용할 수 있다.
- 커리한 함수의 인자중 일부만 적용한 경우 부분 적용 함수라고 한다.
- fun 함수나 함수 값을 사용해 함수를 표현할 수 있다.
- fun 함수는 진짜 함수가 아닌 메소드 이다.
- 함수값으로 정의한 함수는 값처럼 다룰 수 있다.
- 함수 값은 람다 혹은 fun 함수에 대한 참조를 사용해 구현이 가능하다.
- 함수를 합성해 새 함수를 만들 수 있다.
- 함수 값이 필요한 위치에 람다 혹은 함수 참조를 사용할 수 있다.
- 타입을 활용해 컴파일 시점에 타입 오류를 감지하여 보다 안전한 프로그램을 만들 수 있다. 
