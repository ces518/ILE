# 코틀린을 다루는 기술

## 9장 지연계산 사용하기
- 일반적인 경우에는 프로그래밈 결과가 분명해서 문제가 생기기전 까지 지연 계산이나 즉시 계산에 관해 생각하는사람은 없다.
- 코틀린은 즉시 계산 언어이지만, 지연 계산을 사용할 수 있다.

### 즉시 계산과 지연 계산
- 일반적으로 지연 계산과 지연 계산은 언어가 함수나 메소드 인자를 어떻게 계산하는지에 관한 이야기이다.
- 하지만 실제로는 모든 언어가 지연 계산언어이다.
  - 지연 계산이야 말로 프로그래밍의 진정한 정수이기 때문
- 프로그래밍은 실행시점에 **평가가 이뤄질 프로그램 명령어를 조합** 하는 것으로 이뤄진다.
- 즉시 계산 언어라고 해서 **즉시 계산된 요소들을 합성한 것이 아니다.**
- 즉시 계산 언어는 메소드나 함수 인자 평가시 즉시 계산을 사용하지만, 다른 구성요소들은 지연 계산이다.

```kotlin
val result = 
        if (testCondition()) {
            getIfTrue()
        } else {
            getIfFalse()
        }
```
- if-else 구조에서 testCondition() 은 항상 평가 된다.
- 하지만 결과에 따라 getIfTrue() 또는 getIfFalse() 는 둘중 하나만 호출 된다.
- 조건에 대해서는 즉시 계산이지만, 두 분기에 대해서는 지연 계산을 사용한다.

> 즉시 계산이나 지연 계산을 제어 구조나 함수 인자에만 적용되지 않고 프로그래밍의 모든 요소에 적용 된다.

### 코틀린과 즉시 계산
- 코틀린은 즉시 계산 언어이다.
- 함수 인자는 **값으로 전달 (passed by value)** 된다. (인자를 계산한 뒤 결괏값을 함수에 넘긴다.)
- 지연 계산 언어에서는 인자를 **이름으로 전달 (passed by name)** 한다. (인자를 계산하지 않고 넘긴다.)
> 코틀린의 경우 함수에 전달되는 인자는 대부분 참조이며, 함수에 전달될 시 주소 값이 전달된다.

- 코틀린은 항상 즉시 계산만 사용하는것은 아니다. 다음은 코틀린이 지연계산을 적용하는 요소의 예이다.
1. 논리연산자 || 와 &&
2. if - else
3. for 루프
4. while 루프

- 코틀린은 Sequence 와 같은 지연 계산 요소를 제공하며, 프로퍼티 지연 계산도 제공한다.

### 코틀린과 지연 계산
- 지연 계산이 필요한 경우가 많이 존재한다.
- 코틀린 에서도 if - then - 루프 - try - catch 등 블록에서 지연 계산을 사용한다.
- 지연 계산을 사용하지 않는다면, 예외가 발생하지 않아도 catch 블록이 실행되는 등 문제가 발생한다.
- 이처럼 오류에 대한 처리를 제공하려면 지연 계산을 반드시 써야하는 것처럼, 무한한 데이터 구조를 조작하고 싶을 때도 지연 계산이 필수이다.

#### Delegate
- 다음 예제는 코틀린에서 위임을 통해 지연 계산을 구현하는 예제이다.
```kotlin
val first: Boolena by Delegate()
```
- Delegate 클래스는 반드시 아래 함수를 구현해야 한다.
```kotlin
operator fun getValue(thisRef: Any?, property: KProperty<*>): Boolean
```
- Delegate 클래스는 특정 인터페이스를 구현할 필요가 없다. getValue 함수만 선언하고 구현한다면, 코틀린이 **리플렉션** 을 통해 이를 호출한다.
- val 대신 var (가변 프로퍼티) 를 선언하고 싶다면 getValue 뿐만이 아닌 setValue 함수를 반드시 정의 및 구현해 주어야한다.
```kotlin
operator fun setValue(thisRef: Any?, property: KProperty<*>): Boolean
```
> 코틀린 에서는 표준 위임 클래스를 제공하며, 표준 위임 클래스 중에는 지연 계산을 구현할 때 사용가능한 Lazy 가 존재한다.

### 지연 계산 구현
- 코틀린에서 지연 계산을 완벽히 구현하는 것은 불가능하다.
- 인자가 없는 상수를 이용해 원하는 대로 동작이 가능하게끔 가능하다.
```kotlin
val first = { true }
val second = { throw IllegalStateException() }
println(first() || second())
println(or(first, second))

fun or(a: () -> Boolean, b: () -> Boolean): Boolean = if (a()) true else b()
```
- 리터럴값에 대한 참조를 지연 초기화하는 것도 의미가 없어 보이지만, 우리가 원하는 대로 동작하게 된다.
- 하지만 진정한 지연 계산가 비교했을때 큰 차이점이 있다.
- 값을 여러번 사용할 경우, 함수도 여러번 호출된다는 점이다.
- 필요시 마다 매번 재계산하는 방식을 **이름으로 호출 (call by name)** 이라고 한다.

> 최초 시점에 단 한번만 호출하는 방법이 필요하다. 
> 이런 방식을 **필요에 의한 호출 (call by need)** 라고 하며 이는 메모화가 바로 해법이다.