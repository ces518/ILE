# 코틀린을 다루는 기술

## 8장 고급 리스트 처리

### length 의 단점
- 리스트를 접는 (fold) 과정은 초깃값부터 시작해, 같은 함수를 리스트의 각 원소에 연속적으로 합성하는것으로 이루어 진다.
- 접는 연산의 실행시간은 리스트의 길이에 비례한다.
- 5장에서 구현했던 length 함수는 각 원소마다 + 1 을 더하는 방식을 사용해 리스트의 길이를 구하는 방식을 사용했다.
- 원소의 타입과는 상관없이 항상 구현이 같을 수 있다.

`앞서 구현했던 length 함수`
```kotlin
fun length(): Int = foldLeft(0) { { _ -> it + 1} }
```

### 성능 문제
- 접기 연산은 결과를 계산하는데 걸리는 시간이 리스트의 길이에 비래한다.
- 만약 원소가 100만개가 넘어간다면, length 함수의 수행시간은 기하급수적으로 늘어날 것이다.
- 이런 경우 원소의 개수를 어딘가에 저장하고, 리스트에 원소를 추가할 때 마다 해당 값을 갱신하는 방법을 사용해야 한다.
- 문제는 이 메모화한 값을 어디에 저장해야 하는가 ? -> 리스트 자체에 저장하라.
