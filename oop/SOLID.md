# SOLID


#### SRP 단일 책임의 원칙
- 어떤 클래스를 수정하는 이유는 오직 하나여아만 한다.

여자친구 -> 남자친구역할  ->  남자 
어머니  ->  아들 역할   ->   ..
상사    ->  사원 역할   ->  .. 

* 남자의 역할과 책임이 너무 많다..
  객체지향 세계에서는 이를 냄새나는 코드라고 표현한다.
  어느날 여자친구와 헤어졌다고 가정하면, 남자에겐 더이상 그 역할이 필요없으나 다른 역할에도 영향이 미치게된다..
  
이런 경우에 역할을 분리하는것이 단일 책임의 원칙이다.

여자친구 -> 남자친구

직장상사 -> 사원

어머니 -> 아들 

"남자" 라는 하나의 클래스가 역할과 책임에 따라 3개의 클래스로 쪼개어졌다.
남자친구가 이별을 하더라도 나머지 역할들은 영향을 받지 않게된다.



#### OCP 개방 폐쇄의 원칙
- 확장에는 열려있고 , 변경에는 닫혀있어야한다.

가장 좋은예는 JDBC이다.

데이터베이스를 Oralce -> MySQL 로 바꾼다고 해도 Connection 부분만 수정될뿐 , 쿼리를 요청하고 처리하는 부분은 수정이 필요없다.
OCP의 가장 좋은예이다. 


#### LSP 리스코프 치환 원칙
- 서브타입은 언제나 슈퍼타입을 대체 할 수 있어야한다.

* 상속은 조직도나 계층도가아닌 ' 분 류 도 ' 가 되어야 한다.

- 하위클래스 is a kind of 상위클래스
- 구현 클래스 is able to 인터페이스 

위 두개의 문장대로 구현된 프로그램이라면 , LSP를 잘 지키고있다고 할 수 있다.



#### ISP 인터페이스 분리 원칙
- SRP의 예제에서 제시한 해결책은 남자클래스를 하나의 역할만 하는 다수의 클래스로 분리하는 것이었다.
- ISP에서의 해결책은 각 역할의 인터페이스로 제한하는것이 핵심이다.

여자친구 -> 남자친구(interface) -> 남자

직장상사 -> 사원(interface) -> 남자

어머니 -> 아들(interface) -> 남자

결론적으로 SRP와 ISP는 같은 문제의 두 가지 다른 해결책이다.

일반적으로는 SRP가 좋은 해결책이다.

* 인터페이스 최소주의 원칙
- 외부에는 최소한의 메서드만 제공해야한다.

* 상위클래스는 풍성 할 수록 좋고, 인터페이스는 작을 수록 좋다.


#### DIP 의존성 역전의 법칙
- 추상화된 인터페이스나 상위클래스를 두어 영향 받지 않도록 하는것이 의존성 역전의 법칙이다.

자동차 -> 스노우타이어
- 스노우 타이어를 일반타이어로 교체하면 자동차가 스노우타이어에 의존적이기 때문에 자동차에 그 영향이 가게된다.


자동차 ->      타이어
      스노우타이어 일반타이어
      
- 자동차가 추상회된 타이어 인터페이스에 의존함으로써 타이어가 변경되어도 영향이 없다.
