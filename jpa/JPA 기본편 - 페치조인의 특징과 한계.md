# JPA 기본편 - 페치조인의 특징과 한계

### 페치조인의 특징과 한계
#### 페치 조인 대상에는 별칭을 줄 수 없다.
- 하이버네이트는 가능하지만, 가급적 사용하지 말것
    - 페치 조인은 관련된 엔티티를 모두 가져오는것이다.
    - 팀과 연관된 회원이 4명인데 1명만 가져오고싶다 ? => 페치조인을 사용해선 안됨
    - 잘못된 결과를 초례할 수 있다. (CASCADE 등 영속성 관련 옵션들 때문에 데이터가 사라지는 등 상황이 발생할 수 있다.)

- **객체 그래프 탐색이라는 것은 기본적으로 연관된 데이터를 모두 조회**할 수 있어야한다.
    - JPA가 의도한 올바른 방향이다.
- 위와 같은 케이스의 경우에는 **팀에서 페치조인을해 멤버를 찾는것이 아닌, 멤버를 대상으로 조회하는것** 이 올바른 방향이다.

```java
// 다음과 같은 형태로 사용해서는 안된다.
// 페치 조인이라는 것은 기본적으로 연관된 데이터를 모두 가져오는 것이다.
// 필터링 해서 가져오고 싶다면 따로 조회를 해야한다.
// 연관된 데이터를 필터링해서 가져온 뒤 조작하게 될경우 누락된 데이터에 의해 잘못된 결과를 초례할 수 있다.
// 페치조인을 일반적으로 별칭을 주지않는것이 관례이다.
// JPA 에서의 의도한 설계는 t.members 로 그래프 탐색을 했을때, 팀과 연관된 멤버가 모두 있어야한다.
em.createQuery("select t from Team t join fetch t.members as m where m.age > 10");
```

> 데이터 정합성이나, 객체 그래프 사상에 맞지 않기 때문에 별칭은 사용하지 않아야한다.

#### 둘 이상의 컬렉션은 페치조인 할 수 없다.
- 데이터 정합성에 맞지 않을 수 있다.
- **일대다 의 경우에도 카티시안곱이 되어버리는데, 둘 이상의 컬렉션을 페치조인 할경우 정말 예상치못한 데이터가 나올 수 있다.**

> 데이터 정합성에 맞지 않을 수 있고, 기본적으로 사용하지 못하도록 되어있다.

#### 컬렉션을 페치조인 하면 페이징 API를 사용할 수 없다.
- 일대일, 다대일 과 같은 단일 연관관계 필드들은 페치조인을 해도 페이징이 가능하다.
- 페이징은 데이터베이스 기준이기 때문에 로우수를 줄여버린다.
- 하이버네이트는 경고 로그를 남기고, 메모리에서 페이징을 진행한다 (매우 위험함)
- 이때 하이버네이트는 회원에 대한 페이징을 한다면, 회원에 대한 모든 데이터를 싹다 가져온뒤 메모리에서 진행함..

```java
//컬렉션을 페치조인 하면 페이징 API를 사용할 수 없다.
//하이버네이트에서는 경고메시지를 남기고, 메모리에서 페이징을 한다.
//이때 나가는 쿼리는, 페이징 쿼리가 나가지않는다.
//=> DB 에서 팀에대한 모든 데이터를 끌어온다 (100만건이라면 100만건을 메모리에 모두 올린다음에 페이징을 한다..)
em.createQuery("select t from Team t join fetch  t.members m")
        .setFirstResult(0)
        .setMaxResults(10)
        .getResultList();
```

> 컬렉션 페치조인시 페이징은 방향을 뒤집어서 해결하는 방법도 있다.

```java
// 이런 경우, 다음과 같이 방향을 바꾸어 해결하는 방법도 있다.
// 멤버와, 팀을 뒤집으면 회원이 다대일 이기때문에 페이징에 문제가 없다.
em.createQuery("select m from Member m join fetch m.team t");
```

또다른 해결방법은 @BatchSize 를 활용해 해결을 한다.
- 보통 1000이하의 값중에 큰 값을 준다.

```java
// 다른 방법은, 페치조인을 제거한다.
// 제거 직후에는 members가 lazy loading 이기 때문에, team의 members를 사용할때  N + 1 문제가 발생한다.
// 이때  @BatchSize(size = 100) 를 사용한다.
// => 보통 1000이하의 값중에 크게준다.
// BatchSize를 지정하면, Team을 가져올때 현재 members는 레이지 로딩이다.
// IN 쿼리를 할때, 100개씩 날린다. ( Team의 결과가 4개라면 IN 쿼리 로 4개의 팀에대한 멤버를 모두 가져온다.)
// => IN 쿼리의 갯수는 BatchSize의 size 옵션 으로 지정한다.
// 이를 이용하면 최적화가 많이 된다
em.createQuery("select t from Team t")
        .setFirstResult(0)
        .setMaxResults(2)
        .getResultList();

@Entity
public class Team {

    @Id @GeneratedValue
    private Long id;
    private String name;

    // lazy loading 상태에서, 한번에 IN 쿼리로 100개(사이즈값 만큼) 씩 넘긴다.
    // 1 + 1 방식으로 해결한다.
    // 페이징을 해서 팀이 10개라면, IN 쿼리로 팀의 아이디가 10개가 세팅되어 10개의 팀과 연관된 멤버를 모두 긁어온다.
    // N + 1 문제를 해결하는 다른 방법이다.
    @BatchSize(size = 100)
    @OneToMany(mappedBy = "team")
    private List<Member> members = new ArrayList<>();
}
```

- 연관된 엔티티를 SQL 한번으로 조회한다 - 성능 최적화
- 엔티티에 직접 적용하는 글로벌 로딩 전략보다 우선이다.
    - @OneToMany(fetch = FetchType.LAZY) // 글로벌 로딩 전략
    - 페치 조인이 항상 최우선
- 실무에서 글로벌 로딩전략은 모두 지연로딩
- 최적화가 꼭 필요한 곳은 페치 조인을 적용한다

> JPA 에서의 성능문제는 대부분 N + 1 문제이기 때문에 80% 정도는 페치조인으로 해결이 가능하다.

#### 정리
- 모든것을 페치조인으로 해결할 수는 없다.
- 객체 그래프를 유지할 때 사용하면 매우 효과적이다.
    - 객체 그래프 탐색시 유용
- 여러 테이블을 조인해서 엔티티가 가진 모양이 아닌 전혀 다른 결과를 내야한다면, 일반 조인을 사용하고 필요한 데이터만 조회해서 DTO로 반환하는것이 효과적이다.

> 페치 조인에 대해 100% 이해해야한다.. 제대로 알지 못하고 사용한다면, 예상치 못한 문제를 야기할 수 있다.
