# 실전 스프링부트와 JPA 활용 2 - API 개발과 성능 최적화_컬렉션조회_V3_페이징

#### V3 엔티티를 DTO로 변환 - 페이징과 한계돌파
- 컬렉션을 페치 조인하면 페이징이 불간으하다.
    - 일대다 조인이 발생하므로 데이터가 예측할 수 없이 증가한다.
    - 일대다에서 일(1)을 기준으로 페이징을 하는것이 목적이다 하지만 데이터는 다(N)를 기준으로 row가 생성된다.
    - Order를 기준으로 페이징 하고 싶은데, 다(N)인 OrderItem을 조인하면 OrderItem이 기준이 되어버린다.

> 이 경우 하이버네이트는 경고 로그를 남기고, 모든 데이터를 메모리에서 페이징을 시도한다. (최악의 경우 메모리 초과로 서버 장애가 날 수 있다.)

#### 한계 돌파
- 페이징 + 컬렉션 엔티티를 함께 조회하려면 어떻게 해야할까 ?
- 대부분 페이징 + 컬렉션 엔티티 조회 문제는 아래 방법으로 해결이 가능하다.

- 1.ToOne 관계를 모두 페치 조인한다.
    - 페이징에 영향을 주지 않는다.
- 2.컬렉션은 지연 로딩으로 조회한다.
    - 데이터가 뻥튀기 되기 때문
- 3.지연 로딩 성능 최적화를 위해 hibernate.default_batch_fetch_size (글로벌 설정), @BatchSize(개별 설정) 를 설정한다.

> 이 방법을 사용하면 컬렉션이나 프록시 객체를 한꺼번에 설정한 size 만큼 IN 쿼리로 조회한다.

`장점`
- 쿼리 호출 수가 N + 1 -> 1 + 1 로 최적화 된다.
- 조인보다 DB 데이터 전송량이 최적화 된다.
- 페치 조인 방식과 비교해서 쿼리 호출 수가 약간 증가하지만, DB데이터 전송량이 감소한다.
- 컬렉션 페치 조인은 페이징이 불간으 하지만, 이 방법은 페이징이 가능하다.

> ToOne 관계는 페치 조인을 하더라도 페이징에 영향을 주지 않는다. 따라서 ToOne관계는 페치 조인으로 쿼리 수를 줄이고, 해결하고, 나머지는 BatchSize옵션으로 최적화 할것

`참고`
- default_batch_fetch_size 는 100 ~ 1000 사이로 선택하는것을 권장한다.
- DB에 따라 IN 쿼리를 1000으로 제한하기도 한다.
- DB입장에서 순간 부하가 올 수 도 있기 때문임.
- **와스 입장에서는 모든 데이터를 로드해야하기 때문에 메모리사용량이 같다.**
    - 옵션과 무관하다.

> 어떤 값이 딱 적정값이다 라기 보다는 상황에 따라 다르기 때문에 적절하게 최적화 하는것이 중요하다.
