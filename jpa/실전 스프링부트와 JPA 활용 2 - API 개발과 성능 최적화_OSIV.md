# 실전 스프링부트와 JPA 활용 2 - API 개발과 성능 최적화_OSIV

#### OSIV 와 성능 최적화
- Open Session In View: 하이버네이트
- Open EntityManager In View: JPA

> 관례상 OSIV라고 명칭한다.

- 명확하게 이해하고 가지 않으면 장애가 날 수 있다.

#### OSIV ON 전략
최신 스프링 부트는 spring.jpa.open-in-view 가 true로 되어있다고 경고 메시지를 나타낸다.
- OSIV 전략은 트랜잭션 시작 처럼 **최초 데이터베이스 커넥션 시작 시점부터 API 응답이 끝날때 까지 영속성 컨텍스트와, 데이터베이스 커넥션을 유지한다.**
  - **OSIV설정이 커져있다면 트랜잭션이 끝나도, 커넥션을 반환하지 않는다.**
- 따라서 지금까지 View Template, API 컨트롤러에서 지연로딩이 가능 했던 것이다.

```properties
spring.jpa.open-in-view: true # 기본값
```

`단점`
- 이 전략은 너무 오랫동안 데이터베이스 커넥션을 물고 있기때문에, 실시간 트래픽이 중요한 애플리케이션에서는 커넥션으 모자랄 수 있다.
- 이는 장애로 이어질 수 있다.

> 컨트롤러에서 외부 API를 호출하면 API 대기 시간만큼 커넥션 리소스를 유지해야한다. (치명적인 단점)

#### OSIV OFF 전략

```properties
spring.jpa.open-in-view: false
```
- OSIV를 끄면 트랜잭션을 종료할 떄 영속성 컨텍스트를 닫고, 커넥션도 반환한다.

`단점`
- 모든 지연로딩을 트랜잭션 내에서 처리해야한다.
- View Template에서도 지연로딩이 동작하지 않는다.

> 지금까지 작성한 많은 지연로딩 코드를 트랜잭션 안으로 집어 넣어야한다는 단점이 있다.


#### 해결 방법
- 핵심 비즈니스용 서비스와 쿼리용 서비스를 별도의 서비스로 분리 한다.
  - OrderQueryService등..
  - OrderQueryService 내부에서 변환로직 자체를 돌린뒤에 반환한다 (트랜잭션 내이기 때문에 영속성 컨텍스트를 사용할 수 있음)

> Query용 서비스는 DTO를 반환하는등 화면에 종속적인 경우에 사용

#### 커맨드와 쿼리를 분리
- OSIV를 끈 상태로 복잡성을 관리하는 좋은 방법은 커맨드와 쿼리를 분리하는 것이다.
- 보통 비즈니스로직은 성능 이 크게 문제되지 않는다.
- 대부분 복잡한 화면을 출력하기 위한 쿼리는 화면에 맞추어 최적화하는것이 중요하다.
- 크고 복잡한 애플리케이션일 수록 핵심 비즈니스로직 서비스와, 화면이나 API에 맞춘 서비스를 분리하는것을 추천한다. (주로 읽기전용 트랜잭션)

> 한 서비스에 핵심 비즈니스로직과, 쿼리용 로직을 한곳에 녹여놓으면 유지보수성이 떨어진다. (둘의 라이프사이클이 다르다.)


#### 정리
- OSIV전략을 사용하면, 지연로딩에 신경쓰지 않아도 되고, OrderQueryService를 따로 관리 하지 않아도 됨
- OSIV전략을 사용하지 않는다면 성능에서 이점이 있다.
- 어드민 서비스 같은곳에서는 OSIV를 키고, 그렇지 않다면 끄는것을 추천한다.

> 실시간 서비스가 중요하다면 OSIV를 끄고, QueryService를 따로 두는것을 추천한다.
