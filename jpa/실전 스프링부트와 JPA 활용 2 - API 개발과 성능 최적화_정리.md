# 실전 스프링부트와 JPA 활용 2 - API 개발과 성능 최적화_정리

#### API 개발 정리
- 엔티티 조회
  - 엔티티를 그대로 반환
  - 사용해선 안됨
- 엔티티조회후 DTO로 변환
  - API 스펙에 맞게 변환
- 페치 조인으로 쿼리수 최적화
- 컬렉션 페이징과 한계돌파
  - 컬렉션은 페치 조인시 페이징이 불가능
  - ToOne 관계는 페치 조인으로 쿼리수 최적화
  - 컬렉션은 페치조인 대신에 지연 로딩을 유지하고, hibernate.default_batch_fetch_size, @BatchSize 로 최적화

- DTO 직접 조회
  - JPA에서 DTO를 직접 조회
  - 컬렉션 조회 최적화
    - 일대다 관계인 컬렉션은 IN절을 이용해 메모리에서 미리 조회해 최적화
  - 플렛 데이터 최적화
    - JOIN 결과를 그대로 조회 후 애플리케이션에서 원하는 모양으로 직접 변환


#### 권장 개발 순서
- 1.엔티티 조회 방식으로 우선 접근한다
  - 1-1.페치조인으로 쿼리 수를 최적화한다.
  - 1-2.컬렉션 최적화
    - 1-2-1.페이징이 필요할경우 hibernate.default_batch_size, @BatchSize 로 최적화
    - 1-2-2.페이징이 필요없을 경우 -> 페치조인을 사용
- 2.엔티티 조회 방식으로 해결이 안된다면 DTO조회 방식을 사용한다.
- 3.DTO 조회 방식으로 해결이 안되면 NativeSQL or JdbcTemplate 을 사용

> 엔티티 조회 방식은 페치조인 이나 옵션값 설정만으로 다양한 성능 최적화가 가능하지만, DTO 방식은 성능 최적화시 많은 코드를 수정해야한다.

> 개발자는 성능최적화와 코드 복잡도 사이에서 줄타기를 해야한다. 항상 그런 것은 아니지만, 보통 성능 최적화는 단순한 코드를 복잡한 코드로 몰고 간다.
> 엔티티 조회 방식은 JPA 가 많은 부분을 최적화해주기 때문에 단순한 코드를 유지하면서 성능 최적화가 가능하다.

#### DTO 조회 방식 선택지
- DTO로 조회 하는 방법도 각각 장단점이 있다. 단순하게 쿼리가 1번 실행된다고 항상 좋은 방법이 아니다.
- API가 제공하는 기능에 따라 섣부른 최적화가 될 수 있다.
